<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">HBase SCP &amp; TRSP | Ddupg</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ddupg.github.io/blog/20220416-HBase-SCP-and-TRSP"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="HBase SCP &amp; TRSP | Ddupg"><meta data-rh="true" name="description" content="最近在组内进行的一次SCP和TRSP两个Procedure执行过程的分享，在这里记录一下，懒得去整理出文章了"><meta data-rh="true" property="og:description" content="最近在组内进行的一次SCP和TRSP两个Procedure执行过程的分享，在这里记录一下，懒得去整理出文章了"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2020-04-16T15:20:00.000Z"><meta data-rh="true" property="article:author" content="https://ddupg.github.io"><meta data-rh="true" property="article:tag" content="HBase"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ddupg.github.io/blog/20220416-HBase-SCP-and-TRSP"><link data-rh="true" rel="alternate" href="https://ddupg.github.io/blog/20220416-HBase-SCP-and-TRSP" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://ddupg.github.io/blog/20220416-HBase-SCP-and-TRSP" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Ddupg RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Ddupg Atom Feed"><link rel="stylesheet" href="/assets/css/styles.5600f49e.css">
<link rel="preload" href="/assets/js/runtime~main.4d065054.js" as="script">
<link rel="preload" href="/assets/js/main.0b75af7f.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Ddupg</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/navigation">导航</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/ddupg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230921-hbase-metaspace-memory-leak">记一次线上HBase服务JVM metaspace内存泄漏问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230916-the-part-of-postgresql-we-hate-the-most">译：The Part of PostgreSQL We Hate the Most</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230824-hbase-mvcc">HBase MVCC基本原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230706-hbase-snapshot">HBase Snapshot基本原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230523-compaction-offload-paper">论文：Compaction management in distributed key-value datastores</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">HBase SCP &amp; TRSP</h1><div class="container_mt6G margin-vert--md"><time datetime="2020-04-16T15:20:00.000Z" itemprop="datePublished">2020年4月16日</time> · <!-- -->阅读需 13 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://ddupg.github.io" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Ddupg</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>最近在组内进行的一次SCP和TRSP两个Procedure执行过程的分享，在这里记录一下，懒得去整理出文章了 😜</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="amv2">AMv2<a href="#amv2" class="hash-link" aria-label="AMv2的直接链接" title="AMv2的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="比较重要的类">比较重要的类<a href="#比较重要的类" class="hash-link" aria-label="比较重要的类的直接链接" title="比较重要的类的直接链接">​</a></h3><p><img loading="lazy" alt="AMv2主要的类" src="/assets/images/amv2-2f91d7e4ca3bdaccfcb134b65d0b65f9.png" width="1256" height="654" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="assignmentmanager">AssignmentManager<a href="#assignmentmanager" class="hash-link" aria-label="AssignmentManager的直接链接" title="AssignmentManager的直接链接">​</a></h4><p>管理Region的assign/unassign操作，管理Region的状态信息。</p><p>其中主要属性：</p><ul><li>RegionStates: 管理内存中的Region状态信息，RS上有哪些region</li><li>RegionStateStore: 操作meta表</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="regionstatenode">RegionStateNode<a href="#regionstatenode" class="hash-link" aria-label="RegionStateNode的直接链接" title="RegionStateNode的直接链接">​</a></h4><ul><li>lock: 对Region状态信息和RegionLoacation信息加锁，防止并发修改。</li><li>regionInfo: Region信息</li><li>event: 用于多个procedure等待Region的某个状态变化，比如open、close。</li><li>procedure: 记录唯一绑定的TRSP，保证每个Region只能同时进行一个TRSP。</li><li>regionLocation: region要被assign到哪个RS。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="procedureevent">ProcedureEvent<a href="#procedureevent" class="hash-link" aria-label="ProcedureEvent的直接链接" title="ProcedureEvent的直接链接">​</a></h4><p>用于多个Procedure等待某个依赖的事件，在AMv2中，主要的就是等待Region的状态变化。</p><p><img loading="lazy" alt="ProcedureEvent" src="/assets/images/ProcedureEvent-9c68161b068f8ef7283f3bb74fbe04b6.png" width="419" height="222" class="img_ev3q"></p><p>事件状态就两种：</p><ul><li>ready: 某个事件已准备好，可以继续执行</li><li>suspend: 事件未准备好，之后调用suspendIfNotReady()方法的Procedure都会被加到 suspendedProcedure队列里，用于之后唤醒。</li></ul><p>主要方法：</p><ul><li>suspendIfNotReady: 如果是ready状态，表示可以继续执行；如果suspend状态，Procedure会被加到 suspendedProcedure队列里，用于之后唤醒。这时候Procedure会抛出ProcedureSuspendedException，Pv2框架会暂停Procedure的执行，等待被唤醒。</li></ul><p>这个功能有个问题就是只保存在内存中，无法恢复，如果Procedure使用不好，Master重启，等待队列无法恢复，Procedure可能永远无法被唤醒。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="servercrashprocedure">ServerCrashProcedure<a href="#servercrashprocedure" class="hash-link" aria-label="ServerCrashProcedure的直接链接" title="ServerCrashProcedure的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="触发条件">触发条件<a href="#触发条件" class="hash-link" aria-label="触发条件的直接链接" title="触发条件的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="zk-session-expire被动触发">zk session expire（被动触发）<a href="#zk-session-expire被动触发" class="hash-link" aria-label="zk session expire（被动触发）的直接链接" title="zk session expire（被动触发）的直接链接">​</a></h4><p>监听zk上rs节点的变化，如果代表某个rs的子节点被过期删除，就触发SCP。</p><p>配置: {zookeeper.znode.parent}/{zookeeper.znode.rs}/</p><p>默认: /hbase/{cluster name}/rs/</p><p>此种情况下，如果rs处于非ONLINE状态，不会强制执行ServerCrashProcedure</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="hbck2-主动触发">HBCK2 （主动触发）<a href="#hbck2-主动触发" class="hash-link" aria-label="HBCK2 （主动触发）的直接链接" title="HBCK2 （主动触发）的直接链接">​</a></h4><p>要使用完整的ServerName，包含后面的startcode。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./hbase hbck -j hbase-hbck2-1.0.0-SNAPSHOT.jar scheduleRecoveries c4-hadoop-tst-st84.bj,55600,1586416554312 c4-hadoop-tst-st85.bj,55600,1586415546993</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>无论rs是否处于ONLINE状态，都会强制执行 HBCKServerCrashProcedure（ServerCrashProcedure的子类），大多数情况下行为和ServerCrashProcedure一样，不同的地方在于getRegionsOnCrashedServer方法：</p><p>如果ServerCrashProcedure.getRegionsOnCrashedServer返回空集合，HBCKServerCarshProcedure会scan读meta表，将meta表上记录的Opening和Opened两种状态的region返回，另外将Closing状态的region改为Close。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="状态变化">状态变化<a href="#状态变化" class="hash-link" aria-label="状态变化的直接链接" title="状态变化的直接链接">​</a></h3><p><strong>准备工作</strong></p><p>将当前处理的rs加到 DeadServer processing list。在SCP执行结束之后，才加到 DeadServers list。每个状态都会检查下，是否加进去了。</p><p><strong>等待meta表可用</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_START:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_SPLIT_META_LOGS:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_DELETE_SPLIT_META_WALS_DIR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_ASSIGN_META:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// If hbase:meta is not assigned, yield.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (env.getAssignmentManager().waitMetaLoaded(this)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new ProcedureSuspendedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前面几个状态都是操作meta表的region的状态，所以meta表不可用也会执行，其他的状态会操作普通region，涉及到meta表的读写，所以其他状态都要求meta表的region可用，才可以继续执行。这里就利用了ProcedureEvent这个类的功能，等待meta region加载完成之后才允许继续下面的状态，否则直接抛出ProcedureSuspendedException暂停当前Procedure的执行，等待被唤醒。</p><p><strong>但这里好像使用AssignmentManager.metaAssignEvent更合适</strong>。因为meatLoadedEvent只有在Master启动之后才会触发一次，metaAssignEvent在Master启动和每次meta region open都会触发，所以metaAssignEvent来代表meta region可用更合适一些。</p><p><img loading="lazy" alt="SCP流程图" src="/assets/images/SCP-58989e5b9729bf091278156057abc06f.png" width="1339" height="1541" class="img_ev3q"></p><ul><li>START: 没有什么实际操作，根据RS上是否有meta表的region，来判断下一步的状态</li><li>SPLIT_META_LOGS: split meta表的WAL</li><li>DELETE_SPLIT_META_WALS_DIR: 删除HDFS上meta表split log的目录</li><li>ASSIGN_META: 重新assign meta region</li><li>GET_REGIONS: 查询RS上除meta外的region</li><li>SPLIT_LOGS: split非meta表的WAL</li><li>DELETE_SPLIT_WALS_DIR: 删除HDFS上非meta表的WAL目录</li><li>ASSIGN: assign 非meta的region</li><li>FINISH: 收尾工作，将RS加到 DeadServers list，触发CP</li></ul><p>其实这些状态主要可以做的就是Split WAL，Delete WAL dir，Assign region这三类，只不过将Region按是否是meta做了区分，meta region和普通region分别做了这三类操作。这里我理解原因应该是普通的region assign需要读写meta表，所以要求meta表的region必须可用才行，所以优先对meta region进行三步操作处理，meta region可用之后才会进行普通region的三步操作。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题">问题<a href="#问题" class="hash-link" aria-label="问题的直接链接" title="问题的直接链接">​</a></h3><p><strong>执行SCP的时候，RS上的region是怎么处理的？</strong></p><p>直接置为ABNORMALLY_CLOSED，认为所有的region都已经不可用了。</p><p>如果region有TRSP在进行，就进一步通知所有这些region的TRSP和RRP，做对应的操作。
如果没有，就新加TRSP去assign这些region。</p><p>如果rs再恢复或启动的话，也应该会发现zk的节点丢了，不能直接open它的region。（这个没有去看代码确认）</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="transitregionstateprocedure">TransitRegionStateProcedure<a href="#transitregionstateprocedure" class="hash-link" aria-label="TransitRegionStateProcedure的直接链接" title="TransitRegionStateProcedure的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="主要变量">主要变量<a href="#主要变量" class="hash-link" aria-label="主要变量的直接链接" title="主要变量的直接链接">​</a></h3><p><strong>type/initialState/lastState</strong></p><table><thead><tr><th>type</th><th>initialState</th><th>lastState</th></tr></thead><tbody><tr><td>ASSIGN</td><td>GET_ASSIGN_CANDIDATE</td><td>CONFIRM_OPENED</td></tr><tr><td>UNASSIGN</td><td>CLOSE</td><td>CONFIRM_CLOSED</td></tr><tr><td>MOVE</td><td>CLOSE</td><td>CONFIRM_OPENED</td></tr><tr><td>REOPEN</td><td>CLOSE</td><td>CONFIRM_OPENED</td></tr></tbody></table><p><strong>remoteProc</strong></p><p>绑定的某个RegionRemoteProcedureBase，用于执行open/close region这样的RPC操作，这里也只能有一个remoteProc，表示不能同时进行多个操作region状态的RPC。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="状态流转">状态流转<a href="#状态流转" class="hash-link" aria-label="状态流转的直接链接" title="状态流转的直接链接">​</a></h3><p><img loading="lazy" alt="TRSP状态简图" src="/assets/images/TRSP-simple-a558be829bcc6130a60a3c902c396ddc.png" width="817" height="372" class="img_ev3q"></p><p>可以看出来，TRSP中的5个状态形成一个环，通过initialState和lastState两个状态判断入环和出环的状态。</p><p>像ASSIGN和UNASSIGN两个操作，只需要跑完自己的状态就行了。MOVE/REOPEN操作则要先close然后open，不同的是，通过指定RegionStateNode.regionLocation来指定open在哪个RS上，open的rs变化了就是MOVE，不变就是REOPEN。</p><p>ASSIGN: GET_ASSIGN_CANDIDATE -&gt; OPEN -&gt; CONFIRM_OPENED<br>
<!-- -->UNASSIGN: CLOSE -&gt; CONFIRM_CLOSED<br>
<!-- -->MOVE/REOPEN: CLOSE -&gt; CONFIRM_CLOSE -&gt; GET_ASSIGN_CANDIDATE -&gt; OPEN -&gt; CONFIRM_OPENED  </p><p>简图中一些异常情况下的状态流转没有展示出来，比如如果close失败，会再将region open，然后再close，就会在环上转圈。就是说执行过程中出现问题，就会在环上循环执行，直到满足条件达到lastState最终出环。</p><p><img loading="lazy" alt="TRSP状态图" src="/assets/images/TRSP-0acef2ffb80beb4272a59cd963c82d85.png" width="1287" height="776" class="img_ev3q"></p><p><strong>准备工作</strong></p><p>执行之前必须获取RegionStateNode的锁，因为执行过程中，会多次对其中的数据（state、regionLocation）做修改，前面讲过，为保证RegionStateNode的属性不会并发修改，所有修改之前都要先拿锁。</p><p><strong>GET_ASSIGN_CANDIDATE</strong></p><p>主要做的事情就是为Region指定一个RS，将Region放入AM的pendingAssignQueue之后，直接suspend等待。AM以生产者消费者模式为Region指定RS，然后唤醒Procedure。</p><p><strong>OPEN</strong></p><ol><li>如果没有指定regionLocation，则有可能是上一步GET_ASSIGN_CANDIDATE出现问题。或者上一步执行过程中，Master重启，Procedure重试执行了。这时候重新执行上一步就好了。</li><li>如果成功制定了regionLocation，就通过OpenRegionProcedure去通知RS open该region。<ol><li>如果OpenRegionProcedure最终成功执行完了，TRSP继续执行</li><li>如果失败了，会在下一步CONFIRM_OPENED进行重试</li><li>如果Master重启，导致无法唤醒，OpenRegionProcedure有超时机制，超时之后会再重试。</li></ol></li></ol><p><strong>CONFIRM_OPENED</strong></p><p>检查OPEN操作最终是否成功。</p><ol><li>如果Region成功OPEN<ol><li>要看lastState是否就是CONFIRM_OPENED，是的话就完事了。</li><li>不是的话要再执行CLOSE操作。就像简图中的环上一样执行。有可能出现的一种情况是，当merge/split region的时候，要unassign一个region，但过程中RS crash了，就得先把这个region open了，再执行unassign操作，防止RS crash时数据丢失无法恢复。</li></ol></li><li>重试次数达到上限，直接结束</li><li>抹掉regionLocation，重新执行GET_ASSIGN_CANDIDATE</li></ol><p><strong>CLOSE</strong></p><ol><li>region当前的状态合理，通过CloseRegionProcedure，执行过程类似于OpenRegionProcedure。</li><li>不合理直接再去GET_ASSIGN_CANDIDATE走OPEN的逻辑</li></ol><p><strong>CONFIRM_CLOSED</strong></p><ol><li>如果Region当前状态是CLOSE，说明上一步执行成功了<ol><li>如果lastState == CONFIRM_CLOSED，说明当前状态就是要求的最终状态，可以结束了。</li><li>否则，说明可能是move或者reopen操作，需要再assign region，去GET_ASSIGN_CANDIDATE走OPEN的逻辑。<strong>只有这一个地方回到GET_ASSIGN_CANDIDATE没有抹掉regionLocation</strong>。</li></ol></li><li>如果Region当前状态是CLOSING，说明close rpc执行失败了，rs没有回调通知（eg. rs重启了），一直等到了CloseRegionProcedure超时触发了TRSP继续执行，才走到了当前状态，需要再重新Close一次。</li><li>走到这里的Region可能是ABNORMALLY_CLOSED状态，应该只有RS crash才会导致这个状态。<ol><li>如果非default region，ABNORMALLY_CLOSED可以被当作CLOSE处理，直接结束掉。只有开启了read region replicas功能才有这样的region。非default region不接收写操作，所以即使非正常close也不会造成数据丢失。</li><li>Region close异常，需要再open之后再正常close，保证数据不会丢失。原因和CONFIRM_OPENED里的逻辑类似，比如merge/split region的时候，要先close region，如果失败了，则必须先恢复region再重新close，避免数据丢失。</li></ol></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题-1">问题<a href="#问题-1" class="hash-link" aria-label="问题的直接链接" title="问题的直接链接">​</a></h3><p><strong>region merge/split是怎么处理的？</strong></p><p>region merge/split分别是由MergeTableRegionsProcedure和SplitTableRegionProcedure来执行的，它们步步骤都可以拆分成region assign/unassign，也就会拆成不同的TRSP去执行。</p><p>以 region split为例</p><ol><li>close父region（unassign）</li><li>处理好子region的信息保存之后</li><li>open子region（assign）</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="regionremoteprocedurebase">RegionRemoteProcedureBase<a href="#regionremoteprocedurebase" class="hash-link" aria-label="RegionRemoteProcedureBase的直接链接" title="RegionRemoteProcedureBase的直接链接">​</a></h3><p>RegionRemoteProcedureBase是OpenRegionProcedure和CloseRegionProcedure的父类，实现了基本的RPC相关功能。RegionRemoteProcedureBase与TRSP的配合主要也是利用了ProcedureEvent机制。</p><p><img loading="lazy" alt="RegionRemoteProcedureBase时序图" src="/assets/images/RegionRemoteProcedureBase-b15690d1fc59375f46f06f3bc50ed9bb.png" width="821" height="421" class="img_ev3q"></p><ol><li>addOperationToNode方法就是将RPC操作封装起来，放到一个集合中等待执行。</li><li>执行当前Region的ProcedureEvent.suspend操作，等待RPC执行完毕之后唤醒。</li><li>RSProcedureDispatcher会分批将RPC操作按RS和操作类型分类，批量请求某个RS。</li><li>RS执行完对应操作之后，通过reportTransition通知AM（当然中间还有Master），Region open/close完成。</li><li>然后AM就会唤醒RegionStateNode.event，继续执行RegionRemoteProcedureBase</li><li>RegionRemoteProcedureBase执行完成之后，继续执行TRSP后续步骤。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="问题-2">问题<a href="#问题-2" class="hash-link" aria-label="问题的直接链接" title="问题的直接链接">​</a></h4><p><strong>RPC回调之后，怎么确定对应的哪个Procedure？</strong></p><p>RegionInfo -&gt; AM.regionStates (类型 RegionStates) -&gt; RegionStates.regionMap (类型 Map&lt;byte[], RegionStateNode&gt;) -&gt; RegionStateNode.procedure (类型 TRSP) -&gt; TRSP.remoteProc (类型 RegionRemoteProcedureBase) -&gt; RegionRemoteProcedureBase.reportTransition</p><p><strong>RS重启导致没有RPC回调，或者Master重启之后event队列丢失 怎么办？</strong></p><p>RegionRemoteProcedureBase有个超时限制，超时之后重新再执行一次。</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/h-base">HBase</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/ddupg/ddupg.github.io/tree/main/blog/20220416-HBase-SCP-and-TRSP/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/20220618-first-try-gatsby"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">初尝Gatsby</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/20200314-HBase不停服跨集群数据迁移"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">HBase不停服跨集群数据迁移</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#amv2" class="table-of-contents__link toc-highlight">AMv2</a><ul><li><a href="#比较重要的类" class="table-of-contents__link toc-highlight">比较重要的类</a></li></ul></li><li><a href="#servercrashprocedure" class="table-of-contents__link toc-highlight">ServerCrashProcedure</a><ul><li><a href="#触发条件" class="table-of-contents__link toc-highlight">触发条件</a></li><li><a href="#状态变化" class="table-of-contents__link toc-highlight">状态变化</a></li><li><a href="#问题" class="table-of-contents__link toc-highlight">问题</a></li></ul></li><li><a href="#transitregionstateprocedure" class="table-of-contents__link toc-highlight">TransitRegionStateProcedure</a><ul><li><a href="#主要变量" class="table-of-contents__link toc-highlight">主要变量</a></li><li><a href="#状态流转" class="table-of-contents__link toc-highlight">状态流转</a></li><li><a href="#问题-1" class="table-of-contents__link toc-highlight">问题</a></li><li><a href="#regionremoteprocedurebase" class="table-of-contents__link toc-highlight">RegionRemoteProcedureBase</a></li></ul></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Ddupg. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4d065054.js"></script>
<script src="/assets/js/main.0b75af7f.js"></script>
</body>
</html>