<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">译：The Part of PostgreSQL We Hate the Most | Ddupg</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ddupg.github.io/blog/20230916-the-part-of-postgresql-we-hate-the-most"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="译：The Part of PostgreSQL We Hate the Most | Ddupg"><meta data-rh="true" name="description" content="译：The Part of PostgreSQL We Hate the Most"><meta data-rh="true" property="og:description" content="译：The Part of PostgreSQL We Hate the Most"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-09-16T03:15:18.626Z"><meta data-rh="true" property="article:author" content="https://ddupg.github.io"><meta data-rh="true" property="article:tag" content="数据库,后端"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ddupg.github.io/blog/20230916-the-part-of-postgresql-we-hate-the-most"><link data-rh="true" rel="alternate" href="https://ddupg.github.io/blog/20230916-the-part-of-postgresql-we-hate-the-most" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://ddupg.github.io/blog/20230916-the-part-of-postgresql-we-hate-the-most" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Ddupg RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Ddupg Atom Feed"><link rel="stylesheet" href="/assets/css/styles.5600f49e.css">
<link rel="preload" href="/assets/js/runtime~main.9ce1d8a2.js" as="script">
<link rel="preload" href="/assets/js/main.022dfa13.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Ddupg</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/navigation">导航</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/ddupg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230921-hbase-metaspace-memory-leak">记一次线上HBase服务JVM metaspace内存泄漏问题</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/20230916-the-part-of-postgresql-we-hate-the-most">译：The Part of PostgreSQL We Hate the Most</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230824-hbase-mvcc">HBase MVCC基本原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230706-hbase-snapshot">HBase Snapshot基本原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/20230523-compaction-offload-paper">论文：Compaction management in distributed key-value datastores</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">译：The Part of PostgreSQL We Hate the Most</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-09-16T03:15:18.626Z" itemprop="datePublished">2023年9月16日</time> · <!-- -->阅读需 24 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://ddupg.github.io" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Ddupg</span></a></div><small class="avatar__subtitle" itemprop="description">数据库工程师</small></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>最近学习了MySQL的MVCC实现，然后看到了这篇博客详细介绍了PG MVCC的实现，以及这种实现有哪些问题。既能深入理解数据库MVCC实现基本原理，也能对比MySQL和PG的MVCC实现，理解为什么PG的MVCC深受吐槽，所以翻译了这篇文章。</p><p><a href="https://ottertune.com/blog/the-part-of-postgresql-we-hate-the-most/" target="_blank" rel="noopener noreferrer">原文链接</a></p><p>当前有大量的数据库可供选择（到2023年4月有897个）。在2000年代，最普遍的选择是MySQL。最近5年，PostgreSQL成为互联网上最受欢迎的数据库。因为它可靠，有丰富的feature，可扩展，适合大多数工作负载。</p><p>尽管PostgreSQL很受欢迎，但它有些方面还不是很好。这篇博客想讨论下一个很严重的问题：PostgreSQL怎么实现MVCC（多版本并发控制）。我们在卡耐基梅隆大学的研究，以及对Amazon RDS上PostgreSQL数据库实例的优化经验表明，它的MVCC实现是主流数据库（MySQL、Oracle、Microsoft SQL Server）中最差的。并且，Amazon的Aurora也有这些问题。</p><p>在这篇文章中，我们深入MVCC：</p><ul><li>MVCC是什么？</li><li>PostgreSQL怎么实现的？</li><li>为什么很糟糕？</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是mvcc">什么是MVCC？<a href="#什么是mvcc" class="hash-link" aria-label="什么是MVCC？的直接链接" title="什么是MVCC？的直接链接">​</a></h2><p>在DBMS中MVCC的目的是允许读和写并行执行而尽可能不会相互干扰。MVCC的基本思路是不会覆盖写入已经存在的行。对每一（逻辑上的）行，维护多个版本。当应用执行一个查询，DBMS根据版本号（像时间戳）选择适合当前查询的版本。这个方法的优点是多个查询可以同时读更老版本的数据，而不会阻塞更新。查询观察到的是DBMS开启事务时的快照（快照隔离）。这个方法不需要在更新时增加行锁去堵塞对相同行的读请求。</p><p>我们认为1978年David Reed的 <a href="https://dspace.mit.edu/handle/1721.1/16279" target="_blank" rel="noopener noreferrer">Concurrency Control in Distributed Database Systems</a> 是第一篇描述MVCC的出版物。1980年代，<a href="https://en.wikipedia.org/wiki/InterBase#History" target="_blank" rel="noopener noreferrer">InterBase</a>是第一个使用MVCC实现的商业DBMS。从这之后，几乎近20年诞生的支持事务的DBMS都实现了MVCC。</p><p>当实现一个支持MVCC的DBMS时必须做几个设计决策。从较高的层面来看，它可以归结为以下几点：</p><ol><li>对已经存在的行，怎么存储对它的更新</li><li>对查询来说，怎么找到一行数据的正确版本</li><li>怎么删除不再可见的过期版本</li></ol><p>这些决策并不互斥。在PostgreSQL的例子中，他们在1980年代解决第一个问题的方式导致我们今天仍需解决其他两个问题。</p><p>之后的讨论我们使用下面这个例子：一张电影信息表。表中的每行数据包含电影名、发布年份、导演、和一个唯一ID作为主键，以及在电影名和导演字段上建立二级索引。下面是这个表的DDL命令。</p><div class="language-SQL codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-SQL codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE TABLE movies (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name VARCHAR(256) NOT NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  year SMALLINT NOT NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  director VARCHAR(128)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE INDEX idx_name ON movies (name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE INDEX idx_director ON movies (director);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个表包含一个主键索引 <code>movies_pkey</code> 和两个B+树的二级索引 <code>idx_name</code>, <code>idx_director</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="postgresql-的-mvcc">PostgreSQL 的 MVCC<a href="#postgresql-的-mvcc" class="hash-link" aria-label="PostgreSQL 的 MVCC的直接链接" title="PostgreSQL 的 MVCC的直接链接">​</a></h2><p>PostgreSQL自设计之初就支持多版本。PostgreSQL MVCC的核心思想很直接：当更新已经存在的行时，对行数据做一份拷贝，并将更新应用到拷贝后的版本上，而不是在已有行上覆盖更新。我们称这种方式为<code>append-only</code>的版本存储方式。但这个方法对系统的其余部分有一些重要的影响。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="多版本的存储方式">多版本的存储方式<a href="#多版本的存储方式" class="hash-link" aria-label="多版本的存储方式的直接链接" title="多版本的存储方式的直接链接">​</a></h3><p>PostgreSQL在相同的存储空间中存储表的所有版本数据。为了更新已经存在的tuple，DBMS首先为新版本申请一个空的slot。然后拷贝当前版本的行数据作为新版本，再应用更新到新版本中。你可以在下面的例子中看到这个过程，</p><p><img loading="lazy" src="/assets/images/p1-4303dfa7b3ee7139e31ea9b8ae66f1d1.png" width="1056" height="422" class="img_ev3q"></p><p>现在对于一个逻辑行已经存在两个版本，DBMS需要记录这些版本的关系，以便之后查询。DBMS通过一个基于单向链表的版本链来实现这个目的。版本链只能按一个方向去迭代以减少存储和维护开销。这意味着DBMS必须决定使用哪个顺序：<em>newest-to-oldest</em>（N2O）或者<em>oldest-to-newest</em>（O2N）。</p><blockquote><p>版本链的存储方式是单向链表，只能按一个方向迭代查找。</p></blockquote><p>对于N2O顺序，每个tuple版本指向它的前一个版本，版本链的头节点总是最新的版本。对于O2N顺序，每个tuple版本指向它的新版本，并且头节点是最老的tuple版本。O2N方法避免了在每次修改的时候还要去更新索引使其指向新版本。</p><p>然而，在查询时为了找到最新版本可能要花很长时间在版本链上迭代。大多数的DBMS，包括Oracle和MySQL都是N2O实现。但PostgreSQL仍然使用O2N。</p><blockquote><p>O2N的方式，通过索引找到旧版本，再通过版本链找到合适的新版本。
所以数据更新如果不涉及索引字段变化，可以不用更新索引。但代价就是使用索引的查询效率更低。</p></blockquote><p>下一件事是PostgreSQL在版本指针里记录了什么。每行记录的header包含一个tuple id字段（t_tcid）指向下一个版本（如果它自己就是最新版本则指向它自己）。因此，像下面例子展示的，当查询一行记录最新版本的数据时，DBMS需要根据索引，加载最老的版本，然后沿着指针迭代找到它需要的版本。</p><p><img loading="lazy" src="/assets/images/p2-b1b95d3eb74124ff0c1acb03d00c11ed.png" width="1056" height="422" class="img_ev3q"></p><p>PostgreSQL的开发者很早就意识到MVCC设计的两个问题。首先，每次更新都拷贝整个tuple很昂贵。第二，查询最新版本要迭代整个版本链代价也很高。</p><p>为了避免迭代整个版本链，PostgreSQL的索引为一行数据的每个版本都添加一条记录。这意味着如果一个逻辑行有5个版本，索引中就会有5条记录。在下面的例子中，我们看的索引<code>idx_name</code>包含一条记录的两个版本，分散在两个page中。这使得可以直接访问最新版本的tuple，而不用迭代整个版本链。</p><p><img loading="lazy" src="/assets/images/p3-799edc1ab71417ce9c60075a0d05303e.png" width="1056" height="422" class="img_ev3q"></p><p>PostgreSQL使用 <a href="https://www.postgresql.org/docs/current/storage-hot.html" target="_blank" rel="noopener noreferrer">heap-only tuple (HOT)</a> updates技术，将新版本的拷贝放到和旧版本同一个page中，避免去更新多条索引记录和跨page存储多个相关版本的数据，以此减少磁盘IO。如果更新字段不涉及索引相关的列，并且旧版本所在的page有足够的空间，就可以使用HOT方式优化。在我们的例子中，在更新后索引仍然指向旧版本，查询请求通过迭代版本链获取最新版本。正常操作期间，PostgreSQL通过删除旧版本来优化查询。</p><blockquote><p>为了加速索引查询效率，修改时也在索引中增加指向新版本的记录。但每次都更新索引代价也高，所以提出HOT update技术，如果修改不涉及索引字段变化，且新旧版本仍然在同一个page中，就不去更新索引。
我觉得这种方案的考虑可能是：在一个page中迭代版本链是内存操作速度快，但如果新旧记录跨page，就会涉及一次磁盘随机IO，通过索引找到旧版本，再迭代版本链找新版本，那何不直接由索引指向新版本，节省跨页时的磁盘IO。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="版本清理">版本清理<a href="#版本清理" class="hash-link" aria-label="版本清理的直接链接" title="版本清理的直接链接">​</a></h3><p>我们已经确定PostgreSQL在更新时会产生新的版本。下一个问题是怎么回收无效版本。在PostgreSQL的早期版本中并不清理无效版本。想法是存储所有的历史版本，允许应用查询任意时间点的数据。但不清理无效版本意味着表空间不会收缩。也意味着频繁更新tuple的长版本链，这会降低查询速度。除非PostgreSQL的索引可以直接找的正确的版本而不用迭代版本链。但这又意味着索引会变大，降低查询速度，增加存储压力。你现在明白为什么这些问题都是相互关联的了吧。</p><p>为了解决这些问题，PostgreSQL使用了vacuum来清理表中无效的tuple。vacuum会顺序扫描表的数据页找过期版本。一个版本，如果没有存活的事务可见，就会被认为是过期版本。这意味着当前没有事务正在访问这个版本，之后的事务也会访问更新的版本。因此删除过期版本并回收空间是安全的。</p><p>PostgreSQL按照配置的固定时间间隔，自动执行vacuum（autovacuum）。除了有影响所有表的全局配置之外，PostgreSQL还提供表级别的配置。用户也可以通过<code>VACUUM</code>命令手动触发。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="为什么postgresql的mvcc是最糟糕的">为什么PostgreSQL的MVCC是最糟糕的<a href="#为什么postgresql的mvcc是最糟糕的" class="hash-link" aria-label="为什么PostgreSQL的MVCC是最糟糕的的直接链接" title="为什么PostgreSQL的MVCC是最糟糕的的直接链接">​</a></h2><p>老实说：如果今天有人要实现一个MVCC的MBMS，他们不会采用PostgreSQL的方式实现。在我们的这篇论文里 <a href="https://db.cs.cmu.edu/papers/2017/p781-wu.pdf" target="_blank" rel="noopener noreferrer">2018 VLDB paper</a> (aka “<a href="https://twitter.com/andy_pavlo/status/902863242774634496" target="_blank" rel="noopener noreferrer">the best paper ever on MVCC</a>“)，我们没有找到其他DBMS像PostgreSQL一样实现MVCC。它的设计是1990年代日志结构系统爆发前，1980年代的遗迹。</p><p>让我们讨论PostgreSQL MVCC的4个问题。我们也会讨论为什么其他MVCC的DBMS，像Oracle、MySQL避免了这些问题。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题-1-版本拷贝">问题 #1: 版本拷贝<a href="#问题-1-版本拷贝" class="hash-link" aria-label="问题 #1: 版本拷贝的直接链接" title="问题 #1: 版本拷贝的直接链接">​</a></h3><p>在append-only的存储模式中，如果更新一个tuple，无论修改多少列，DBMS都会拷贝所有的列作为新版本。可以想象，append-only的MVCC会导致大量数据重复和存储需求增加。这个方法意味着PostgreSQL比其他DBMS需要更多的内存和磁盘，意味着更慢的查询和更高的云成本。</p><p>相比于拷贝整个tuple作为新版本，MySQL和Oracle存储的是新版本和当前版本的差异（文章中用的是‘delta’）（就像git diff）。如果一个请求只更新了一张1000列的表中的一列，PostgreSQL需要创建一个新版本，包含修改的1列和未修改的999列。而MySQL这类DBMS只需要记录更新的这一列的差异。</p><blockquote><p>这种方式文章中成为delta versions。后面也直接用这个词。</p></blockquote><p>为了让PostgreSQL的多版本存储更现代化，EnterpriseDB在2013年开始了<a href="https://wiki.postgresql.org/wiki/Zheap" target="_blank" rel="noopener noreferrer">zheap project</a>，尝试使用delta versions的方式替换append-only的存储引擎。遗憾的是失败了。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题-2-表膨胀">问题 #2: 表膨胀<a href="#问题-2-表膨胀" class="hash-link" aria-label="问题 #2: 表膨胀的直接链接" title="问题 #2: 表膨胀的直接链接">​</a></h3><p>PostgreSQL过期版本数据相对于delta versions的方式，会占用更多的存储空间。尽管PostgreSQL的自动清理最终会删掉无效tuple，但写压力大的场景下可能会导致数据增长比清理速度更快，导致数据库的持续增长。因为DBMS把无效tuple和存活tuple混合存储在page中，查询时必须把过期tuple也加载进内存。</p><p>无限的膨胀会增高IOPS并且消耗更多内存，最终降低查询性能。另外，由无效tuple引起的不准确的优化器统计信息可能会导致糟糕的查询计划。</p><p>假设我们的电影表有1000万有效tuple，4000万无效tuple，有80%的无效数据。而且表中列较多，平均每个tuple占用1KB。这种场景下，有效tuple占用10GB存储空间，无效tuple占用40GB空间，整个表占用50GB。</p><p>当一个查询执行全表扫描，PostgreSQL必须从磁盘加载50GB数据，并且存储在内存中，尽管大多数数据是无效数据。尽管PostgreSQL有保护机制避免顺序扫描污染缓存池，但也不能避免IO消耗。</p><p>尽管你可以确定PostgreSQL的自动清理正在周期性执行并且能跟得上你的workload（本身并不容易），自动清理也无法回收存储空间。自动回收会删除每个page上的无效tuple，并且重新存储存活tuple，但他也不会回收磁盘上的空page。</p><blockquote><p>这里的空page只是DBMS逻辑上的空page，像是文件中的空闲区域，仍然受DBMS管理，在后续分配时使用。
而返还OS得对文件重写。</p></blockquote><p>在我们上面的例子中，即使PostgreSQL从电影表中删掉了40GB的无效tuple，它仍然会保留从操作系统申请的50GB存储空间（AWS的RDS就是这个情况）。为了回收这些无用空间，必须使用<code>VACUUM FULL</code>或pg_repack去重写整个表到一片新空间。</p><p>在不考虑生产数据库的性能影响的情况下，运行这两种操作都不是一件容易的事。它们是耗资源且耗时的操作，会拖垮查询性能。下图展示了<code>VACUUM</code>和<code>VACUUM FULL</code>如何工作</p><p><img loading="lazy" src="/assets/images/p4-bf8546dc481f7ed53c9b04c37f787af2.png" width="1575" height="629" class="img_ev3q"></p><p>当PostgreSQL执行<code>VACUUM</code>操作，DBMS只是从表的page中删掉无效tuple，然后重新组织，将所有有效tuple放到page的末尾。而执行<code>VACUUM FULL</code>，PostgreSQL从每个page中删掉无效tuple，重新合并所有剩余存活tuple到一个新的page中(Table Page #3)，并且删掉无用的page(Table Pages #1 / #2)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题3-二级索引的维护">问题#3: 二级索引的维护<a href="#问题3-二级索引的维护" class="hash-link" aria-label="问题#3: 二级索引的维护的直接链接" title="问题#3: 二级索引的维护的直接链接">​</a></h3><p>对一个tuple的一次更新，PostgreSQL要更新表的所有索引，因为PostgreSQL在主键索引和二级索引中存储的都是一个版本的物理地址。除非新版本和旧版本在同一个page上（HOT update），否则就要更新所有索引。</p><p>回到我们<code>UPDATE</code>请求的例子，PostgreSQL在一个新的page上创建了旧版本的拷贝形成新版本。但它也需要在主键索引（movies_pkey）和2个二级索引（idx_director，idx_name）中插入指向新版本的记录。</p><p><img loading="lazy" src="/assets/images/p5-f6394e454d7a57b0e9fdd30a5e11f4c6.png" width="1577" height="746" class="img_ev3q"></p><p>在上图的例子中，展示非HOT update操作时索引的维护。DBMS在Page#2上创建了tuple的一个新版本，然后在表的所有索引中插入一条新纪录指向这个版本。</p><p>每次更新都要修改表的全部索引会带来性能损耗。DBMS增加了额外的I/O去读写每个索引。访问索引也会在索引和DBMS内部数据结构上引入锁竞争（例如buffer pool的page table）。</p><p>另外，对索引的维护工作带来的额外读写对于基于IOPS向用户收费的DBMS是有问题的，像Amazon Aurora。</p><p>根据上面描述的，PostgreSQL通过将新版本与旧版本写在同一个page上（HOT update）来避免更新索引。我们基于OtterTune用户的PostgreSQL数据库分析平均大约46%的更新使用了HOT update。仍然有超过50%的更新要付出这个代价。</p><p>有很多用户例子挣扎于PostgreSQL的MVCC实现的。最著名是Uber 2016年的博客，关于他们<a href="https://www.uber.com/en-HK/blog/postgres-to-mysql-migration/" target="_blank" rel="noopener noreferrer">为什么从Postgres迁到了MySQL</a>。他们写密集型的workload，在一些有较多二级索引的表上，有严重的性能问题。</p><p>Oracle和MySQL在他们MVCC的实现上没有这个问题，因为他们的二级索引不是存储的新版本的物理地址。相反，他们存储了一个逻辑ID（例如 tuple id，主键ID）。这可能会导致读二级索引更慢，因为必须要解析逻辑ID（回表），但这些DBMS在他们MVCC的实现上有其他优势来降低损耗。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题-4-vacuum-management">问题 #4: Vacuum management<a href="#问题-4-vacuum-management" class="hash-link" aria-label="问题 #4: Vacuum management的直接链接" title="问题 #4: Vacuum management的直接链接">​</a></h3><p>PostgreSQL的性能严重依赖autovacuum删除过期数据并回收空间的效率。无论你正在使用的是RDS，Aurora或者Aurora Serverless，所有基于PostgreSQL的变体都有一样的autovacuum问题。</p><p>但是因为其复杂度，很难确保autovacuum可以最佳地运行。PostgreSQL对优化autovacuum的配置并不适合于所有表，尤其是大表。例如，默认autovacuum触发前，更新操作占比至少20%(<a href="https://www.postgresql.org/docs/15/runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR" target="_blank" rel="noopener noreferrer">autovacuum_vacuum_scale_factor</a>)。这个阈值的意思是，如果一张表里有1亿tuple，在更新至少2千万前不会触发autovacuum。因此，PostgreSQL可能保存了大量无效tuple很长时间，这会增加IO和内存消耗。</p><p>PostgreSQL autovacuum的另一个问题是，它可能被长时间运行的事务阻塞，这会导致更多无效tuple的积累和过时的统计数据。未能及时清理过期版本会导致更严重的性能问题，导致更多长时间运行的事务阻塞autovacuum执行。这变成一个恶性循环，要求手动kill掉长时间运行的事务。</p><p>下图展示了一个OtterTune客户的数据库中，两周内无效tuple的数量：</p><p><img loading="lazy" src="/assets/images/p6-df5f4b69dd51b3e4de22e9031cfe443f.png" width="1573" height="628" class="img_ev3q"></p><p>PostgreSQL Amazon RDS 数据库中一段时间​​内失效tuple的数量。</p><p>图中的锯齿状表示autovacuum大约每天执行一次major clean-up。例如，在Feb-14th，DBMS清理了320万的无效tuple。这个图展示的，就是一个不健康的PostgreSQL数据库的例子，因为autovacuum赶不上无效tuple增长的速度。</p><p>在OtterTune，我们经常在用户的数据库中碰到这个问题。一个 PostgreSQL RDS 实例由于批量插入数据后，过时的统计信息导致查询长时间运行。此请求阻塞autovacuum更新统计信息，导致了更多长时间运行的请求。这就需要管理员手动kill掉请求。</p><blockquote><p>根据上文描述，这里的统计信息（statistics）应该是指查询优化器的统计信息，查询优化器统计信息不准，导致查询计划不合理，事务运行时间更长。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="结束语">结束语<a href="#结束语" class="hash-link" aria-label="结束语的直接链接" title="结束语的直接链接">​</a></h2><p>构建 DBMS 时总是必须做出一些艰难的设计决策，这些决定将导致任何 DBMS 在不同的工作负载上表现不同。对于Uber这类写密集型workload，由于PostgreSQL MVCC带来的索引写放大问题，就是他们迁移到MySQL的原因。</p><p>但请不要误解我们的谩骂意味着我们不认为你应该用PostgreSQL。尽管它的MVCC实现采用了错误的方式，PostgreSQL仍然是我们最喜欢的DBMS。热爱某件事就是愿意克服它的缺陷。</p><p>所以如何解决PostgreSQL的问题？你可能会花费大量的时间和精力自己调整它。<a href="https://philbooth.me/blog/nine-ways-to-shoot-yourself-in-the-foot-with-postgresql" target="_blank" rel="noopener noreferrer">祝你好运</a>。</p><p><a href="https://ottertune.com/blog/yes-postgresql-has-problems-but-we-re-sticking-with-it" target="_blank" rel="noopener noreferrer">下一篇博客</a>我们会详细介绍你可以做哪些事情。</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/数据库">数据库</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/后端">后端</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/ddupg/ddupg.github.io/tree/main/blog/20230916-The Part of PostgreSQL We Hate the Most/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/20230921-hbase-metaspace-memory-leak"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">记一次线上HBase服务JVM metaspace内存泄漏问题</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/20230824-hbase-mvcc"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">HBase MVCC基本原理</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是mvcc" class="table-of-contents__link toc-highlight">什么是MVCC？</a></li><li><a href="#postgresql-的-mvcc" class="table-of-contents__link toc-highlight">PostgreSQL 的 MVCC</a><ul><li><a href="#多版本的存储方式" class="table-of-contents__link toc-highlight">多版本的存储方式</a></li><li><a href="#版本清理" class="table-of-contents__link toc-highlight">版本清理</a></li></ul></li><li><a href="#为什么postgresql的mvcc是最糟糕的" class="table-of-contents__link toc-highlight">为什么PostgreSQL的MVCC是最糟糕的</a><ul><li><a href="#问题-1-版本拷贝" class="table-of-contents__link toc-highlight">问题 #1: 版本拷贝</a></li><li><a href="#问题-2-表膨胀" class="table-of-contents__link toc-highlight">问题 #2: 表膨胀</a></li><li><a href="#问题3-二级索引的维护" class="table-of-contents__link toc-highlight">问题#3: 二级索引的维护</a></li><li><a href="#问题-4-vacuum-management" class="table-of-contents__link toc-highlight">问题 #4: Vacuum management</a></li></ul></li><li><a href="#结束语" class="table-of-contents__link toc-highlight">结束语</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Ddupg. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.9ce1d8a2.js"></script>
<script src="/assets/js/main.022dfa13.js"></script>
</body>
</html>