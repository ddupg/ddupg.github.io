<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ddupg.github.io/blog</id>
    <title>Ddupg Blog</title>
    <updated>2022-06-26T12:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ddupg.github.io/blog"/>
    <subtitle>Ddupg Blog</subtitle>
    <icon>https://ddupg.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Docusaurus建站（3）- hygen生成页面模版]]></title>
        <id>docusaurus-website-3</id>
        <link href="https://ddupg.github.io/blog/docusaurus-website-3"/>
        <updated>2022-06-26T12:00:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<p>写博客每次都要写一堆matter信息，贼麻烦，用hygen工具生成。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="hygen使用">hygen使用<a class="hash-link" href="#hygen使用" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="macos安装">MacOS安装<a class="hash-link" href="#macos安装" title="标题的直接链接">​</a></h3><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ brew tap jondot/tap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ brew </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> hygen</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其他系统或安装方式参考官网。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="初始化项目">初始化项目<a class="hash-link" href="#初始化项目" title="标题的直接链接">​</a></h3><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ </span><span class="token builtin class-name">cd</span><span class="token plain"> your-project</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ hygen init self</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="添加自己的博客模版">添加自己的博客模版<a class="hash-link" href="#添加自己的博客模版" title="标题的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ hygen generator new blog</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>会产生一个<code>_templates/blog/new/hello.ejs.t</code>文件，把<code>hello.ejs.t</code>改名成<code>index.ejs.t</code></p><div class="language-yml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_Ktv7">_templates/blog/new/index.ejs.t</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">to</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> blog/&lt;%= name %</span><span class="token punctuation" style="color:#393A34">&gt;</span><span class="token plain">/index.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">slug</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">title</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">date</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> &lt;%= h.getBlogDate() %</span><span class="token punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">author</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Ddupg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">author_title</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 数据库工程师</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">author_url</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> https</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//ddupg.github.io</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">tags</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">数据库</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> 后端</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;</span><span class="token tag" style="color:#00009f">!--</span><span class="token plain"> truncate </span><span class="token punctuation" style="color:#393A34">-</span><span class="token punctuation" style="color:#393A34">-</span><span class="token punctuation" style="color:#393A34">&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>每篇博客会生成一个单独的目录。个人习惯，方便在同目录下放图片等其他资源。</li><li>slug和title记得填，不然也跑不起来。</li><li>其他信息可以根据自己情况修改</li><li><code>h.getBlogDate()</code>是自定义的一个工具方法，定义在根目录的<code>.hygen.js</code>。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hygenjs">.hygen.js<a class="hash-link" href="#hygenjs" title="标题的直接链接">​</a></h3><p>在项目根目录下，放一个<code>.hygen.js</code>文件，可以放一些自定义的工具方法，比如模版中的日期生成的方法就放在这里</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_Ktv7">.hygen.js</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">module</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">exports</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token literal-property property" style="color:#36acaa">helpers</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token function-variable function" style="color:#d73a49">getBlogDate</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Date</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">toISOString</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="生成">生成<a class="hash-link" href="#生成" title="标题的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ hygen blog new &lt;blog name&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>执行之后，就会生成新的博客了，文件放在<code>blog/&lt;blog name&gt;/index.md</code>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a class="hash-link" href="#参考" title="标题的直接链接">​</a></h2><ul><li><a href="https://www.hygen.io/" target="_blank" rel="noopener noreferrer">Hygen</a></li></ul>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Docusaurus" term="Docusaurus"/>
        <category label="React" term="React"/>
        <category label="前端" term="前端"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docusaurus建站（2）- 部署到GitHub Pages]]></title>
        <id>docusaurus-website-2</id>
        <link href="https://ddupg.github.io/blog/docusaurus-website-2"/>
        <updated>2022-06-26T11:00:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<p>部署到GitHub Pages。官网支持很多种方法，我选了GitHub Action。
我有几台电脑，几套开发环境，如果每个都配一遍也够麻烦的，毕竟不是专业的前端。用GitHub Action的话，写简单博客或者文档直接push到仓库就好了，甚至可以在GitHub的网页编辑，方便得很。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="新建github仓库上传代码">新建GitHub仓库&amp;上传代码<a class="hash-link" href="#新建github仓库上传代码" title="标题的直接链接">​</a></h2><p>上一步只能在本地运行部署，要把它部署到GitHub Pages，得先上传到GitHub的一个仓库里。</p><p>我这里就是上传到了ddupg.github.io仓库。</p><blockquote><p>以github.io后缀的仓库名，GitHub会默认这是个GitHub Pages项目，如果是其他项目还需要自己配置GitHub Pages。具体看下<a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">官网介绍</a>。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="配置access-token">配置Access Token<a class="hash-link" href="#配置access-token" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="生成">生成<a class="hash-link" href="#生成" title="标题的直接链接">​</a></h3><p>生成一个专用于GitHub Pages部署用的access token，GitHub Action需要用这个token才能部署。</p><p>在自己的GitHub账号里，从页面右上角开始：</p><p><em>Setting -&gt;Developer settings -&gt;  Personal access tokens</em></p><p>生成一个新的token，记得复制下来，马上要用：</p><p><img loading="lazy" alt="new-token.png" src="/assets/images/new-token-77a71a94047528c7490cc4dc2265e41b.png" width="802" height="627" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="配置">配置<a class="hash-link" href="#配置" title="标题的直接链接">​</a></h3><p><img loading="lazy" src="/assets/images/env-var-0b10f2f47d231a7b23df34ff41c09527.png" width="1638" height="848" class="img_ev3q"></p><p>这里的环境变量名后面要用，不要乱起名。环境变量的值，就是上一步生成的token。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="配置github-action">配置GitHub Action<a class="hash-link" href="#配置github-action" title="标题的直接链接">​</a></h2><p>详细的可以看<a href="https://www.docusaurus.cn/docs/deployment#triggering-deployment-with-github-actions" target="_blank" rel="noopener noreferrer">Docusaurus文档</a></p><p>配置GitHub Action非常简单，只需要在自己的项目的固定目录新加个配置文件就好了。</p><ul><li><p>文件名随意。目录必须是：<code>.github/workflows/</code></p></li><li><p>如果你的默认主分支不是main，那就改下<code>on.push.branches</code>。如果其他分支也需要触发，那也加上分支名。</p></li><li><p>如果你的环境变量名字不是<code>ACCESS_TOKEN</code>，就改个环境变量名，其他的不要动</p></li></ul><div class="language-yml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_Ktv7">.github/workflows/ci.yml</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Deploy to GitHub Pages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">push</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">branches</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">jobs</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">deploy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Deploy to GitHub Pages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">runs-on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ubuntu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">latest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">steps</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> actions/checkout@v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> actions/setup</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">node@v3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">with</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">node-version</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 16.x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">cache</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> yarn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Install dependencies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> yarn install </span><span class="token punctuation" style="color:#393A34">-</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">frozen</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">lockfile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Build website</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> yarn build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic"># Popular action to deploy to GitHub Pages:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic"># Docs: https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-docusaurus</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Deploy to GitHub Pages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> peaceiris/actions</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">gh</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">pages@v3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">with</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">github_token</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> $</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> secrets.ACCESS_TOKEN </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token comment" style="color:#999988;font-style:italic"># Build output to publish to the `gh-pages` branch:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">publish_dir</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ./build</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="最后">最后<a class="hash-link" href="#最后" title="标题的直接链接">​</a></h2><p>把修改后的配置文件push到仓库就好了，GitHub Action会自动触发。</p><p>再修改下GitHub Pages使用的分支，这事就成了。</p><p><img loading="lazy" src="/assets/images/github-pages-a97a1ac6b80121310c1c8774bb5f2ea1.png" width="1079" height="503" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a class="hash-link" href="#参考" title="标题的直接链接">​</a></h2><p><a href="https://www.docusaurus.cn/" target="_blank" rel="noopener noreferrer">Docusaurus文档</a></p>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Docusaurus" term="Docusaurus"/>
        <category label="React" term="React"/>
        <category label="前端" term="前端"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docusaurus建站（1）- 项目初始化]]></title>
        <id>docusaurus-website-1</id>
        <link href="https://ddupg.github.io/blog/docusaurus-website-1"/>
        <updated>2022-06-26T10:00:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<p>本想重做自己的博客和文档，本打算从头写，调研了Next.js和Gatsby，都是很强大的框架，但对我个后端开发来说还是很有难度的。无意中看到了Docusaurus框架，能自带文档和博客，还能高度自定义页面，完美匹配我的需求，所以就有了这个系列，打算记录下整个博客改造过程，能写几期不一定，慢慢来吧。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="初始化项目">初始化项目<a class="hash-link" href="#初始化项目" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ npx create-docusaurus@latest my-website classic --typescript</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ yarn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ yarn build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ yarn start # 开发过程中，能自动刷新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ yarn serve # 不会自动刷新</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="修改网站配置">修改网站配置<a class="hash-link" href="#修改网站配置" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="修改网站基本信息">修改网站基本信息<a class="hash-link" href="#修改网站基本信息" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="config-basic.png" src="/assets/images/config-basic-769cf3cfc8811e809d2f3c59aa7666fa.png" width="1102" height="796" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="修改图标导航栏">修改图标&amp;导航栏<a class="hash-link" href="#修改图标导航栏" title="标题的直接链接">​</a></h3><p><img loading="lazy" src="/assets/images/config-navbar-cfd63c0f3bd7bb5a5396da10778ba00e.png" width="926" height="1408" class="img_ev3q"></p><p>制作图标过程中用到的几个工具，都是临时google找的：</p><p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener noreferrer">图片背景消除</a></p><p><a href="https://www.logosc.cn/logo/favicon?s=d" target="_blank" rel="noopener noreferrer">icon图标生成工具</a></p><p><a href="https://www.aconvert.com/cn/image/png-to-svg/" target="_blank" rel="noopener noreferrer">PNG转SVG - 在线转换图像文件</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="修改footer">修改Footer<a class="hash-link" href="#修改footer" title="标题的直接链接">​</a></h3><p><img loading="lazy" src="/assets/images/config-footer-13e3c99e1a491cefa4855282c1193f5c.png" width="1736" height="1660" class="img_ev3q"> &nbsp;</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="删掉自带的博客文档demo">删掉自带的博客/文档Demo<a class="hash-link" href="#删掉自带的博客文档demo" title="标题的直接链接">​</a></h2><p>博客目录：<code>blog/</code>
文档目录：<code>docs/</code></p><p>文档目录只留个<code>intro.md</code>，因为配置里留了这个文件的引用，后面当个主页导航用。</p>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Docusaurus" term="Docusaurus"/>
        <category label="React" term="React"/>
        <category label="前端" term="前端"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[初尝Gatsby]]></title>
        <id>first-try-gatsby</id>
        <link href="https://ddupg.github.io/blog/first-try-gatsby"/>
        <updated>2022-06-18T08:11:00.000Z</updated>
        <summary type="html"><![CDATA[第一次体验Gatsby项目，创建demo项目就碰到了不少问题。]]></summary>
        <content type="html"><![CDATA[<p>第一次体验Gatsby项目，创建demo项目就碰到了不少问题。
笔者用的是MacOS环境。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sharp问题">sharp问题<a class="hash-link" href="#sharp问题" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">❯ Installing Gatsby...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! code 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! path /Users/ddupg/github/gatsby-demo/node_modules/sharp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! command failed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! command sh -c (node install/libvips &amp;&amp; node install/dll-copy &amp;&amp; prebuild-install) || (node install/can-compile &amp;&amp; node-gyp rebuild &amp;&amp; node install/dll-copy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! sharp: Downloading https://github.com/lovell/sharp-libvips/releases/download/v8.12.2/libvips-8.12.2-darwin-x64.tar.br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! sharp: Please see https://sharp.pixelplumbing.com/install for required dependencies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! sharp: Installation error: connect ETIMEDOUT 185.199.111.133:443</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! A complete log of this run can be found in:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ERROR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Command failed with exit code 1: npm install --loglevel error --color always</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>参考<a href="https://juejin.cn/post/6844903856464199687" target="_blank" rel="noopener noreferrer">解决gatsby安装失败sharp: Command failed</a>
这是国内连接github网络不稳，依赖资源下载不了。
从异常中能看出依需要下载的具体包，我这里就是<strong>libvips-8.12.2-darwin-x64.tar.br</strong>，手动从<a href="https://github.com/lovell/sharp-libvips/releases" target="_blank" rel="noopener noreferrer">github</a>下载对应版本，放到<code>~/.npm/_libvips</code>
目录，再尝试就好了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="vips问题">vips问题<a class="hash-link" href="#vips问题" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">❯ Installing Gatsby...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! code 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! path /Users/ddupg/github/my-gatsby-site/node_modules/sharp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! command failed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! command sh -c (node install/libvips &amp;&amp; node install/dll-copy &amp;&amp; prebuild-install) || (node install/can-compile &amp;&amp; node-gyp rebuild &amp;&amp; node install/dll-copy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! sharp: Using cached /Users/ddupg/.npm/_libvips/libvips-8.12.2-darwin-x64.tar.br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! sharp: Integrity check passed for darwin-x64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR!   TOUCH Release/obj.target/libvips-cpp.stamp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR!   CC(target) Release/obj.target/nothing/node_modules/node-addon-api/nothing.o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR!   LIBTOOL-STATIC Release/nothing.a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR!   CXX(target) Release/obj.target/sharp-darwin-x64/src/common.o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! ../src/common.cc:24:10: fatal error: 'vips/vips8' file not found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! #include &lt;vips/vips8&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR!          ^~~~~~~~~~~~</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! 1 error generated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! make: *** [Release/obj.target/sharp-darwin-x64/src/common.o] Error 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! build error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! stack Error: `make` failed with exit code: 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! stack     at ChildProcess.onExit (/Users/ddupg/.node_global/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:194:23)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! stack     at ChildProcess.emit (node:events:526:28)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! stack     at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! System Darwin 19.3.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! command "/usr/local/bin/node" "/Users/ddupg/.node_global/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "rebuild"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! cwd /Users/ddupg/github/my-gatsby-site/node_modules/sharp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! node -v v16.14.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! node-gyp -v v9.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! gyp ERR! not ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">npm ERR! A complete log of this run can be found in:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ERROR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Command failed with exit code 1: npm install --loglevel error --color always</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>参考<a href="https://stackoverflow.com/questions/66363572/vips-vips8-file-not-found-include-vips-vips8-in-ionic-cordova-in-ios" target="_blank" rel="noopener noreferrer">vips/vips8 file not found #include &lt;vips/vips8&gt; in Ionic cordova in IOS</a>
手动安装vips</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">brew install vips</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="其他">其他<a class="hash-link" href="#其他" title="标题的直接链接">​</a></h2><p>国内环境brew下载贼慢，参考<a href="https://zhuanlan.zhihu.com/p/324691527" target="_blank" rel="noopener noreferrer">brew换源</a></p>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Gatsby" term="Gatsby"/>
        <category label="React" term="React"/>
        <category label="前端" term="前端"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[HBase SCP & TRSP]]></title>
        <id>HBase-SCP-and-TRSP</id>
        <link href="https://ddupg.github.io/blog/HBase-SCP-and-TRSP"/>
        <updated>2020-04-16T15:20:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<p>最近在组内进行的一次SCP和TRSP两个Procedure执行过程的分享，在这里记录一下，懒得去整理出文章了 😜</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="amv2">AMv2<a class="hash-link" href="#amv2" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="比较重要的类">比较重要的类<a class="hash-link" href="#比较重要的类" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="AMv2主要的类" src="/assets/images/amv2-2f91d7e4ca3bdaccfcb134b65d0b65f9.png" width="1256" height="654" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="assignmentmanager">AssignmentManager<a class="hash-link" href="#assignmentmanager" title="标题的直接链接">​</a></h4><p>管理Region的assign/unassign操作，管理Region的状态信息。</p><p>其中主要属性：</p><ul><li>RegionStates: 管理内存中的Region状态信息，RS上有哪些region</li><li>RegionStateStore: 操作meta表</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="regionstatenode">RegionStateNode<a class="hash-link" href="#regionstatenode" title="标题的直接链接">​</a></h4><ul><li>lock: 对Region状态信息和RegionLoacation信息加锁，防止并发修改。</li><li>regionInfo: Region信息</li><li>event: 用于多个procedure等待Region的某个状态变化，比如open、close。</li><li>procedure: 记录唯一绑定的TRSP，保证每个Region只能同时进行一个TRSP。</li><li>regionLocation: region要被assign到哪个RS。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="procedureevent">ProcedureEvent<a class="hash-link" href="#procedureevent" title="标题的直接链接">​</a></h4><p>用于多个Procedure等待某个依赖的事件，在AMv2中，主要的就是等待Region的状态变化。</p><p><img loading="lazy" alt="ProcedureEvent" src="/assets/images/ProcedureEvent-9c68161b068f8ef7283f3bb74fbe04b6.png" width="419" height="222" class="img_ev3q"></p><p>事件状态就两种：</p><ul><li>ready: 某个事件已准备好，可以继续执行</li><li>suspend: 事件未准备好，之后调用suspendIfNotReady()方法的Procedure都会被加到 suspendedProcedure队列里，用于之后唤醒。</li></ul><p>主要方法：</p><ul><li>suspendIfNotReady: 如果是ready状态，表示可以继续执行；如果suspend状态，Procedure会被加到 suspendedProcedure队列里，用于之后唤醒。这时候Procedure会抛出ProcedureSuspendedException，Pv2框架会暂停Procedure的执行，等待被唤醒。</li></ul><p>这个功能有个问题就是只保存在内存中，无法恢复，如果Procedure使用不好，Master重启，等待队列无法恢复，Procedure可能永远无法被唤醒。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="servercrashprocedure">ServerCrashProcedure<a class="hash-link" href="#servercrashprocedure" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="触发条件">触发条件<a class="hash-link" href="#触发条件" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="zk-session-expire被动触发">zk session expire（被动触发）<a class="hash-link" href="#zk-session-expire被动触发" title="标题的直接链接">​</a></h4><p>监听zk上rs节点的变化，如果代表某个rs的子节点被过期删除，就触发SCP。</p><p>配置: {zookeeper.znode.parent}/{zookeeper.znode.rs}/</p><p>默认: /hbase/{cluster name}/rs/</p><p>此种情况下，如果rs处于非ONLINE状态，不会强制执行ServerCrashProcedure</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="hbck2-主动触发">HBCK2 （主动触发）<a class="hash-link" href="#hbck2-主动触发" title="标题的直接链接">​</a></h4><p>要使用完整的ServerName，包含后面的startcode。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./hbase hbck -j hbase-hbck2-1.0.0-SNAPSHOT.jar scheduleRecoveries c4-hadoop-tst-st84.bj,55600,1586416554312 c4-hadoop-tst-st85.bj,55600,1586415546993</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>无论rs是否处于ONLINE状态，都会强制执行 HBCKServerCrashProcedure（ServerCrashProcedure的子类），大多数情况下行为和ServerCrashProcedure一样，不同的地方在于getRegionsOnCrashedServer方法：</p><p>如果ServerCrashProcedure.getRegionsOnCrashedServer返回空集合，HBCKServerCarshProcedure会scan读meta表，将meta表上记录的Opening和Opened两种状态的region返回，另外将Closing状态的region改为Close。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="状态变化">状态变化<a class="hash-link" href="#状态变化" title="标题的直接链接">​</a></h3><p><strong>准备工作</strong></p><p>将当前处理的rs加到 DeadServer processing list。在SCP执行结束之后，才加到 DeadServers list。每个状态都会检查下，是否加进去了。</p><p><strong>等待meta表可用</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_START:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_SPLIT_META_LOGS:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_DELETE_SPLIT_META_WALS_DIR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case SERVER_CRASH_ASSIGN_META:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// If hbase:meta is not assigned, yield.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (env.getAssignmentManager().waitMetaLoaded(this)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new ProcedureSuspendedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前面几个状态都是操作meta表的region的状态，所以meta表不可用也会执行，其他的状态会操作普通region，涉及到meta表的读写，所以其他状态都要求meta表的region可用，才可以继续执行。这里就利用了ProcedureEvent这个类的功能，等待meta region加载完成之后才允许继续下面的状态，否则直接抛出ProcedureSuspendedException暂停当前Procedure的执行，等待被唤醒。</p><p><strong>但这里好像使用AssignmentManager.metaAssignEvent更合适</strong>。因为meatLoadedEvent只有在Master启动之后才会触发一次，metaAssignEvent在Master启动和每次meta region open都会触发，所以metaAssignEvent来代表meta region可用更合适一些。</p><p><img loading="lazy" alt="SCP流程图" src="/assets/images/SCP-58989e5b9729bf091278156057abc06f.png" width="1339" height="1541" class="img_ev3q"></p><ul><li>START: 没有什么实际操作，根据RS上是否有meta表的region，来判断下一步的状态</li><li>SPLIT_META_LOGS: split meta表的WAL</li><li>DELETE_SPLIT_META_WALS_DIR: 删除HDFS上meta表split log的目录</li><li>ASSIGN_META: 重新assign meta region</li><li>GET_REGIONS: 查询RS上除meta外的region</li><li>SPLIT_LOGS: split非meta表的WAL</li><li>DELETE_SPLIT_WALS_DIR: 删除HDFS上非meta表的WAL目录</li><li>ASSIGN: assign 非meta的region</li><li>FINISH: 收尾工作，将RS加到 DeadServers list，触发CP</li></ul><p>其实这些状态主要可以做的就是Split WAL，Delete WAL dir，Assign region这三类，只不过将Region按是否是meta做了区分，meta region和普通region分别做了这三类操作。这里我理解原因应该是普通的region assign需要读写meta表，所以要求meta表的region必须可用才行，所以优先对meta region进行三步操作处理，meta region可用之后才会进行普通region的三步操作。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题">问题<a class="hash-link" href="#问题" title="标题的直接链接">​</a></h3><p><strong>执行SCP的时候，RS上的region是怎么处理的？</strong></p><p>直接置为ABNORMALLY_CLOSED，认为所有的region都已经不可用了。</p><p>如果region有TRSP在进行，就进一步通知所有这些region的TRSP和RRP，做对应的操作。
如果没有，就新加TRSP去assign这些region。</p><p>如果rs再恢复或启动的话，也应该会发现zk的节点丢了，不能直接open它的region。（这个没有去看代码确认）</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="transitregionstateprocedure">TransitRegionStateProcedure<a class="hash-link" href="#transitregionstateprocedure" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="主要变量">主要变量<a class="hash-link" href="#主要变量" title="标题的直接链接">​</a></h3><p><strong>type/initialState/lastState</strong></p><table><thead><tr><th>type</th><th>initialState</th><th>lastState</th></tr></thead><tbody><tr><td>ASSIGN</td><td>GET_ASSIGN_CANDIDATE</td><td>CONFIRM_OPENED</td></tr><tr><td>UNASSIGN</td><td>CLOSE</td><td>CONFIRM_CLOSED</td></tr><tr><td>MOVE</td><td>CLOSE</td><td>CONFIRM_OPENED</td></tr><tr><td>REOPEN</td><td>CLOSE</td><td>CONFIRM_OPENED</td></tr></tbody></table><p><strong>remoteProc</strong></p><p>绑定的某个RegionRemoteProcedureBase，用于执行open/close region这样的RPC操作，这里也只能有一个remoteProc，表示不能同时进行多个操作region状态的RPC。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="状态流转">状态流转<a class="hash-link" href="#状态流转" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="TRSP状态简图" src="/assets/images/TRSP-simple-a558be829bcc6130a60a3c902c396ddc.png" width="817" height="372" class="img_ev3q"></p><p>可以看出来，TRSP中的5个状态形成一个环，通过initialState和lastState两个状态判断入环和出环的状态。</p><p>像ASSIGN和UNASSIGN两个操作，只需要跑完自己的状态就行了。MOVE/REOPEN操作则要先close然后open，不同的是，通过指定RegionStateNode.regionLocation来指定open在哪个RS上，open的rs变化了就是MOVE，不变就是REOPEN。</p><p>ASSIGN: GET_ASSIGN_CANDIDATE -&gt; OPEN -&gt; CONFIRM_OPENED<br>
<!-- -->UNASSIGN: CLOSE -&gt; CONFIRM_CLOSED<br>
<!-- -->MOVE/REOPEN: CLOSE -&gt; CONFIRM_CLOSE -&gt; GET_ASSIGN_CANDIDATE -&gt; OPEN -&gt; CONFIRM_OPENED  </p><p>简图中一些异常情况下的状态流转没有展示出来，比如如果close失败，会再将region open，然后再close，就会在环上转圈。就是说执行过程中出现问题，就会在环上循环执行，直到满足条件达到lastState最终出环。</p><p><img loading="lazy" alt="TRSP状态图" src="/assets/images/TRSP-0acef2ffb80beb4272a59cd963c82d85.png" width="1287" height="776" class="img_ev3q"></p><p><strong>准备工作</strong></p><p>执行之前必须获取RegionStateNode的锁，因为执行过程中，会多次对其中的数据（state、regionLocation）做修改，前面讲过，为保证RegionStateNode的属性不会并发修改，所有修改之前都要先拿锁。</p><p><strong>GET_ASSIGN_CANDIDATE</strong></p><p>主要做的事情就是为Region指定一个RS，将Region放入AM的pendingAssignQueue之后，直接suspend等待。AM以生产者消费者模式为Region指定RS，然后唤醒Procedure。</p><p><strong>OPEN</strong></p><ol><li>如果没有指定regionLocation，则有可能是上一步GET_ASSIGN_CANDIDATE出现问题。或者上一步执行过程中，Master重启，Procedure重试执行了。这时候重新执行上一步就好了。</li><li>如果成功制定了regionLocation，就通过OpenRegionProcedure去通知RS open该region。<ol><li>如果OpenRegionProcedure最终成功执行完了，TRSP继续执行</li><li>如果失败了，会在下一步CONFIRM_OPENED进行重试</li><li>如果Master重启，导致无法唤醒，OpenRegionProcedure有超时机制，超时之后会再重试。</li></ol></li></ol><p><strong>CONFIRM_OPENED</strong></p><p>检查OPEN操作最终是否成功。</p><ol><li>如果Region成功OPEN<ol><li>要看lastState是否就是CONFIRM_OPENED，是的话就完事了。</li><li>不是的话要再执行CLOSE操作。就像简图中的环上一样执行。有可能出现的一种情况是，当merge/split region的时候，要unassign一个region，但过程中RS crash了，就得先把这个region open了，再执行unassign操作，防止RS crash时数据丢失无法恢复。</li></ol></li><li>重试次数达到上限，直接结束</li><li>抹掉regionLocation，重新执行GET_ASSIGN_CANDIDATE</li></ol><p><strong>CLOSE</strong></p><ol><li>region当前的状态合理，通过CloseRegionProcedure，执行过程类似于OpenRegionProcedure。</li><li>不合理直接再去GET_ASSIGN_CANDIDATE走OPEN的逻辑</li></ol><p><strong>CONFIRM_CLOSED</strong></p><ol><li>如果Region当前状态是CLOSE，说明上一步执行成功了<ol><li>如果lastState == CONFIRM_CLOSED，说明当前状态就是要求的最终状态，可以结束了。</li><li>否则，说明可能是move或者reopen操作，需要再assign region，去GET_ASSIGN_CANDIDATE走OPEN的逻辑。<strong>只有这一个地方回到GET_ASSIGN_CANDIDATE没有抹掉regionLocation</strong>。</li></ol></li><li>如果Region当前状态是CLOSING，说明close rpc执行失败了，rs没有回调通知（eg. rs重启了），一直等到了CloseRegionProcedure超时触发了TRSP继续执行，才走到了当前状态，需要再重新Close一次。</li><li>走到这里的Region可能是ABNORMALLY_CLOSED状态，应该只有RS crash才会导致这个状态。<ol><li>如果非default region，ABNORMALLY_CLOSED可以被当作CLOSE处理，直接结束掉。只有开启了read region replicas功能才有这样的region。非default region不接收写操作，所以即使非正常close也不会造成数据丢失。</li><li>Region close异常，需要再open之后再正常close，保证数据不会丢失。原因和CONFIRM_OPENED里的逻辑类似，比如merge/split region的时候，要先close region，如果失败了，则必须先恢复region再重新close，避免数据丢失。</li></ol></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题-1">问题<a class="hash-link" href="#问题-1" title="标题的直接链接">​</a></h3><p><strong>region merge/split是怎么处理的？</strong></p><p>region merge/split分别是由MergeTableRegionsProcedure和SplitTableRegionProcedure来执行的，它们步步骤都可以拆分成region assign/unassign，也就会拆成不同的TRSP去执行。</p><p>以 region split为例</p><ol><li>close父region（unassign）</li><li>处理好子region的信息保存之后</li><li>open子region（assign）</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="regionremoteprocedurebase">RegionRemoteProcedureBase<a class="hash-link" href="#regionremoteprocedurebase" title="标题的直接链接">​</a></h3><p>RegionRemoteProcedureBase是OpenRegionProcedure和CloseRegionProcedure的父类，实现了基本的RPC相关功能。RegionRemoteProcedureBase与TRSP的配合主要也是利用了ProcedureEvent机制。</p><p><img loading="lazy" alt="RegionRemoteProcedureBase时序图" src="/assets/images/RegionRemoteProcedureBase-b15690d1fc59375f46f06f3bc50ed9bb.png" width="821" height="421" class="img_ev3q"></p><ol><li>addOperationToNode方法就是将RPC操作封装起来，放到一个集合中等待执行。</li><li>执行当前Region的ProcedureEvent.suspend操作，等待RPC执行完毕之后唤醒。</li><li>RSProcedureDispatcher会分批将RPC操作按RS和操作类型分类，批量请求某个RS。</li><li>RS执行完对应操作之后，通过reportTransition通知AM（当然中间还有Master），Region open/close完成。</li><li>然后AM就会唤醒RegionStateNode.event，继续执行RegionRemoteProcedureBase</li><li>RegionRemoteProcedureBase执行完成之后，继续执行TRSP后续步骤。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="问题-2">问题<a class="hash-link" href="#问题-2" title="标题的直接链接">​</a></h4><p><strong>RPC回调之后，怎么确定对应的哪个Procedure？</strong></p><p>RegionInfo -&gt; AM.regionStates (类型 RegionStates) -&gt; RegionStates.regionMap (类型 Map&lt;byte[], RegionStateNode&gt;) -&gt; RegionStateNode.procedure (类型 TRSP) -&gt; TRSP.remoteProc (类型 RegionRemoteProcedureBase) -&gt; RegionRemoteProcedureBase.reportTransition</p><p><strong>RS重启导致没有RPC回调，或者Master重启之后event队列丢失 怎么办？</strong></p><p>RegionRemoteProcedureBase有个超时限制，超时之后重新再执行一次。</p>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="HBase" term="HBase"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[HBase不停服跨集群数据迁移]]></title>
        <id>HBase不停服跨集群数据迁移</id>
        <link href="https://ddupg.github.io/blog/HBase不停服跨集群数据迁移"/>
        <updated>2020-03-14T15:42:00.000Z</updated>
        <summary type="html"><![CDATA[最近接到两个用户提的JIRA，都是目前数据只存在了一个srv集群，需要将数据备份prc集群做数据备份或者离线计算，同时两集群之间还要做数据实时同步。所以在这里记录下操作过程并介绍下原因。]]></summary>
        <content type="html"><![CDATA[<p>最近接到两个用户提的JIRA，都是目前数据只存在了一个srv集群，需要将数据备份prc集群做数据备份或者离线计算，同时两集群之间还要做数据实时同步。所以在这里记录下操作过程并介绍下原因。</p><p>集群之间增量数据同步自然是利用replication，单向同步配置一个peer，双向同步配置两个peer就好。</p><p>存量数据使用snapshot同步。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="操作步骤">操作步骤<a class="hash-link" href="#操作步骤" title="标题的直接链接">​</a></h2><p><strong>0. 准备工作</strong></p><p>在prc集群新建namespace</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">create_namespace 'ns'</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>1. 新建srv到prc集群的peer</strong></p><p><strong>注意peer要disable掉</strong></p><p>如果之前没有srv到prc集群的peer，直接新建peer</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 复制namespace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add_peer '1', CLUSTER_KEY =&gt; "zk1,zk2,zk3:11000:/hbase/prc", STATE =&gt; "DISABLED", NAMESPACES =&gt; ["ns"]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 复制table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add_peer '1', CLUSTER_KEY =&gt; "zk1,zk2,zk3:11000:/hbase/prc", STATE =&gt; "DISABLED", TABLE_CFS =&gt; { "ns:table1" =&gt; [] }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果之前已经有srv到prc集群的peer，在peer中加入要操作的namespace</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">disable_peer '1'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 新加namespace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">append_peer_namespaces '1', ["ns"]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 新加table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">append_peer_tableCFs '1', { "ns:table1" =&gt; []}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>2. 打snapshot</strong></p><p>将要同步的表打snapshot，如果复制整个namespace，要一个一个打</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">snapshot 'ns:table1', 'ns_table1_snapshot'</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>3. 将snapshot复制到prc集群</strong></p><p>使用<code>ExportSnapshot</code>将snapshot从srv复制到prc集群</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./bin/hbase --config /path/to/conf org.apache.hadoop.hbase.snapshot.ExportSnapshot -copy-from hdfs://srv/hbase/srv -copy-to hdfs://prc/hbase/prc -snapshot ns_table1_snapshot -mappers 100 -bandwidth 512 -overwrite &gt;&gt; copy.log 2&gt;&amp;1 &amp;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>4. 在prc集群使用snapshot生成表</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">clone_snapshot 'ns_table1_snapshot', 'ns:table1'</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>5. 开启peer</strong></p><p>将srv到prc集群的peer打开</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enable_peer '1'</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>6. 其他</strong></p><p>在peer集群加权限</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">grant 'kerberos_name', 'RW', '@ns1'</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果需要俩集群双向同步，在增加prc到srv集群的peer</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">add_peer '2', CLUSTER_KEY =&gt; "zk1,zk2,zk3:11000:/hbase/srv", STATE =&gt; "ENABLED", NAMESPACES =&gt; ["ns"]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="操作原因">操作原因<a class="hash-link" href="#操作原因" title="标题的直接链接">​</a></h2><p>数据复制自然不能丢数据，也就是要保证snapshot的存量数据和replication的增量数据之间不能有间隙，但其实可以有重叠。</p><p>我们先新建replication peer，将现有的WAL和之后再生成的WAL都加进该peer的复制队列中，disable掉peer的原因则是prc集群还没有新建表，replication开始复制则会出现<code>Table xxx does not exist</code>的报错。这一步如果是修改的原有peer，则会导致replication延迟增加。</p><p>之后再打snapshot便不用担心数据有丢失了，此时replication的数据与snapshot的数据已经有重叠了。</p><p>最后总结一句，一定要先新建replication peer，然后在打snapshot。</p>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="HBase" term="HBase"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maven项目以Shaded形式引入第三方依赖库]]></title>
        <id>Shaded-Thirdparty-Dependencies</id>
        <link href="https://ddupg.github.io/blog/Shaded-Thirdparty-Dependencies"/>
        <updated>2020-01-13T17:46:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<p>最近有用户反馈，他的项目中同时使用了HBase和一个RPC框架，HBase依赖2.5.0的protobuf，RPC框架依赖3.7的protobuf，导致他的项目编译都失败。0.98版本的HBase还是使用的原生的protobuf-java依赖，2.0版本才使用了shaded形式的protobuf，所以我们决定自己提供以shaded形式引入protobuf的HBase Client。</p><p>相信这个问题不只是出现在HBase中，或者出现在与protobuf相关的项目中，其实当我们项目间接依赖了像protobuf、netty等大版本之间互不兼容的框架，甚至guava这种某些接口不兼容的框架，都有可能出现类似的问题。这里也是提供一个可以参考的解决方法。</p><p>方法上，参考了HBase 2.0之后对第三方依赖的处理，简单来说就是将常用第三方依赖的代码负责一份，修改所有类的package，发布一个自己的artifact到仓库中。这样肯定就不会再依赖冲突了。</p><p>而protobuf的依赖处理起来则比较麻烦一点，除了修改原生protobuf类的package之外，还需要处理proto生成的Java文件。所以本文就以protobuf为例，提供第三方依赖冲突的解决方案。因为都是使用Maven插件实现，所以也只对Maven项目有用，相信其他项目也有类似的解决办法。</p><p>本文相关代码都已放在<a href="https://github.com/ddupg/demos/tree/master/shaded" target="_blank" rel="noopener noreferrer">Github</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="生成shaded依赖包">生成shaded依赖包<a class="hash-link" href="#生成shaded依赖包" title="标题的直接链接">​</a></h2><p>可以直接参考<a href="https://github.com/ddupg/demos/blob/master/shaded/pom.xml" target="_blank" rel="noopener noreferrer">pom.xml的代码</a>，其中主要使用到的插件是以下几个：</p><ul><li>maven-dependency-plugin 将protobuf依赖包下载下来并解包放在src/main/java目录下，变成自己项目的源码</li><li>maven-shade-plugin 在打包阶段，修改protobuf类的package名。例如HBase项目是将<code>com.google.protobuf</code>改为<code>org.apache.hbase.thirdparty.com.google.protobuf</code>，我的代码中是将<code>com.google.protobuf</code>改为<code>ddupg.demo.thirdparty.com.google.protobuf</code></li><li>maven-clean-plugin 在操作之前，清理下之前生成的文件</li></ul><p>修改好pom文件之后，直接mvn clean deploy发布到仓库就好了，中央仓库和私有仓库都是一样的。</p><p>可以解压target目录下打好的包，就可以看到class文件的package路径已经变化了。因为是在package阶段才修改的package名，所以直接看target/generated-sources下的class文件其实是不变的。</p><p>普通的第三方依赖项目使用这一步其实就可以解决了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="生成proto文件">生成proto文件<a class="hash-link" href="#生成proto文件" title="标题的直接链接">​</a></h2><p>解决掉了protobuf的源文件，下一步就是处理proto生成的文件了。</p><p>因为需要依赖上一步生成的shaded包，而我又没有将它deploy到中央仓库，也没有自己的私人仓库，所以便使用了<a href="https://github.com/apache/hbase-thirdparty" target="_blank" rel="noopener noreferrer">HBase项目的第三方依赖</a>，道理都一样，替换一下dependency就好了。</p><p>可以直接参考<a href="https://github.com/ddupg/demos/blob/master/shaded/shaded-protocol/pom.xml" target="_blank" rel="noopener noreferrer">pom.xml的代码</a>.</p><p>这一步主要使用的插件：</p><ul><li>protobuf-maven-plugin 生成proto文件，这一步生成的文件依旧使用的是原生protobuf。</li><li>com.google.code.maven-replacer-plugin:replacer 替换源代码，将protobuf原生的package路径<code>com.google.protobuf</code>改成第一步中修改后的package名。因为我在这里使用的HBase的第三方依赖项目，所以就是将<code>com.google.protobuf</code>改为<code>org.apache.hbase.thirdparty.com.google.protobuf</code></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a class="hash-link" href="#参考" title="标题的直接链接">​</a></h2><ul><li><a href="https://www.xolstice.org/protobuf-maven-plugin/" target="_blank" rel="noopener noreferrer">Maven Protocol Buffers Plugin</a></li><li><a href="https://maven.apache.org/plugins/maven-shade-plugin/" target="_blank" rel="noopener noreferrer">Apache Maven Shade Plugin</a></li><li><a href="https://code.google.com/archive/p/maven-replacer-plugin/" target="_blank" rel="noopener noreferrer">maven-replacer-plugin</a></li></ul>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Java" term="Java"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[初步了解HBase Region Replicas]]></title>
        <id>Initial-Analysis-Region-Replicas</id>
        <link href="https://ddupg.github.io/blog/Initial-Analysis-Region-Replicas"/>
        <updated>2019-12-05T15:00:00.000Z</updated>
        <summary type="html"><![CDATA[背景]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="背景">背景<a class="hash-link" href="#背景" title="标题的直接链接">​</a></h2><p>CAP原理中，指出对于一个分布式系统来说，不可能同时满足一致性 (Consistency)、可用性（Availability）、分区容错性（Partition tolerance），而HBase则被设计成一个CP系统，保证了强一致性的同时，选择牺牲了一定的可用性。</p><p>在对HBase的压测中，很容易发现虽然HBase的平均读写延迟很低，但却存在很高的毛刺，P99、P999延迟很高，主要的一个影响因素则是单点的GC，另外Region的MTTR（平均修复时间）也较高，一旦某个RegionServer宕机或某个Region出现问题，甚至是一次Full GC，都有可能出现较长时间的不可用，影响可用性。</p><p>HBase的Read Region Replicas功能，提供一个或多个副本，在region恢复期间或请求时间过长时，支持最终一致性的读服务。在一些不要求强一致性的应用中，可以通过此功能来提高可用性降低读请求延迟。</p><p>为了实现高可用读，HBase提供了一个feature，叫<code>region replication</code>。在这种模型下，表的每个region，都会有多个副本，分布在不同的RegionServer上。默认region replication为1，此时与之前的region模型并无不同。当region replication被设置为2或更多时，Master将会assign所有region的secondary region，Load Balancer会保证同一个region的多个备份会被分散在不同的RegionServer上。</p><p>一个region的所有副本都有一个唯一的replica_id。replica_id=0的是primary region（和之前模型中唯一的region一样），其他的副本region被都叫做secondary region。</p><p>primary region，支持读写请求；secondary region，只支持读请求。如此设计保证primary region依旧具有强一致性，同时提高读可用性。但也因为写请求只有primary region可以处理，所以写请求依然会因为primary region不可用而被阻塞，HBase的写可用性依然没有得到改善。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="timeline-consistency">Timeline Consistency<a class="hash-link" href="#timeline-consistency" title="标题的直接链接">​</a></h2><p>在该功能的实现中，HBase提供了一种支持<strong>单次读请求</strong>的一致性定义。</p><div class="language-Java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public enum Consistency {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    STRONG,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TIMELINE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>HBase默认的就是<code>Consistency.STRONG</code>强一致性模型，与之前的模型一样，所有读写操作都通primary region完成。</p><p>而当client使用<code>Consistency.TIMELINE</code>的一致性发起读请求时，会首先向primary region发起请求，一定时间内没有返回响应，则同时并发向所有的secondary region发起请求，最终采用率先返回的请求。为了区分最终的响应是否来自secondary region，在<code>Result</code>中增加了<code>stale</code>的boolean属性，<code>true</code>则表示来自secondary region。</p><p>从语义上讲，HBase的TIMELINE一致性并不同于常见的最终一致性解决方案。</p><ul><li>即使存在多副本，也不需要考虑副本之间数据冲突的问题。</li><li>secondary region接收primary region同步的数据，按同样顺序处理数据，所以secondary region总是primary region在之前某个时刻的快照。从这一点上看，更像是RDBMS（关系型数据库管理系统）的复制、或是HBase多数据中心多集群之间的复制。</li><li>另一方面，client可以自行决定是否需要读取最新数据，自行决定使用哪一种一致性来满足功能需求。</li><li>client依然会读到乱序的数据，比如多次请求发往了不同的region。目前并没有类似于事务的东西来解决这个问题。</li></ul><p><img loading="lazy" alt="Timeline Consistency" src="/assets/images/timeline_consistency-cbd096b06c5cd9b876ac242581fd5752.png" width="720" height="540" class="img_ev3q"></p><p>根据上图我们来更好的理解TIMELINE的语义。首先client1按顺序写了x=1,x=2,x=3，primary region也按写入顺序处理，并将WAL同步给其他secondary region（一种数据同步方式，后面会再讲）。在图中注意到，replica_1只接收到两次更新，所以最终数据是x=2，replica_2只接收到1次更新，数据是x=1。</p><p>如果client1使用STRONG一致性来读数据，都只会和primary region交互，数据都是最新值x=3。可如果使用TIMELINE一致性读取数据，有可能和所有副本做交互，最终获得的数据1、2、3都有可能。如果client请求多次，甚至可能出现数据回退，即第1次请求获得x=2，第2次请求则获得了x=1。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="实现">实现<a class="hash-link" href="#实现" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据模型">数据模型<a class="hash-link" href="#数据模型" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="一个region replication为2的表在meta表中的列" src="/assets/images/meta-4e25459c12011f47545533ebf41291ce.png" title="一个region replication为2的表在meta表中的列" width="1150" height="96" class="img_ev3q"></p><p>在上图中，是一个region replication为2的表在meta表中info列族下的列，可以看到有一些名为info:xxx_0001的列，这些列存储的数据就是replica_id=1的secondary region的数据。同理，当region的备份数量更多时，meta表中名为info:xxx_0002、info:xxx_0003的列存储的则为replica_id为2、3的secondary region的数据。</p><p>明白了meta表中是如何存储secondary region数据，client要获取secondary region所在的RegionServer自然也简单，多解析几个server_xxxx的列便可以了。</p><p><img loading="lazy" alt="client访问secondary region" src="/assets/images/client-read-replicas-ccdc2076b27cf4c406b28e22fcf3f5d0.png" title="client访问secondary region" width="547" height="356" class="img_ev3q"></p><p>上图展示的是client访问secondary region的示意图。HBase的读请求有两种，Get和Scan。对于Get这种无状态的请求，每次RPC对server端来说都是一次独立的请求。client端的用户可以多次超时重试，直到获取到数据；也可以并发请求多个replica，选择率先返回的数据；还可以使用TIMELINE Read，请求primary region超时之后再请求其他secondary region。但对于Scan这种有状态的请求，一次scan可能与同一个region交互多次，也可能跨多个region多个RegionServer请求数据，server端会记录每个scan的状态数据，那么一次scan产生的多次RPC便不能随意地发给所有的replica。</p><p><img loading="lazy" alt="client scan过程" src="/assets/images/client_scan_replicas-fd7fa07654a40cb9ee74b05ea7769eb9.png" title="client scan过程" width="735" height="344" class="img_ev3q"></p><p>上图展示的是client执行一个跨region的scan过程，假设当前表有2个逻辑region（Region_A和Region_B），region的起始区间分别为[a, d)、[d, f)，且该表的region replication为2，即每个逻辑region都有一主一备，4个region分布在4个RegionServer上。当我们执行一次scan操作，设置cacheing为2（每次RPC最多获取2个Result），则scan至少进行4次RPC，图中连线则表示每次RPC，连线上的数字表示RPC的顺序编号，虚线表示RPC超时或返回太慢结果没有被采用。可以看到当client要进行第1次RPC时，将请求同时发给了Region_A的主备2个region，因为此时server端是没有任何关于此次scan的状态数据，client可以选择率先返回响应的region进行后续的RPC交互。当第2次RPC时便不可以随意选择region了，因为Region_A_primary存储了此次scan的状态数据，而Region_A_replica_1没有，如果请求Region_A_replica_1则只会抛出异常。当第2次RPC结束，已经获取了Region_A中的全部数据，便可以清理掉Region_A_primary中存储的状态数据了。当第3次RPC时，和第1次时情况有些类似，server端暂时没有存储scan的状态数据了，client便可以像第1次RPC一样，将请求同时发给了Region_A的主备2个region。第4次RPC则像第2次一样。总结一下：当scan进行TIMELINE Read时，只有对每个逻辑region的第1次rpc可以任意选择region请求。</p><p>目前，Read Region Replicas功能并没有支持批量请求，即批量Get、Scan都是直接请求primary region。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据同步">数据同步<a class="hash-link" href="#数据同步" title="标题的直接链接">​</a></h3><p>secondary region要支持读请求，则必然要有数据，而secondary region又不支持写请求，那么数据是哪来的呢？</p><p><img loading="lazy" alt="RegionServer 内部结构" src="/assets/images/rs-structure-4c2478b8d9d3eed71dec635557afba24.png" title="RegionServer 内部结构" width="691" height="369" class="img_ev3q"></p><p>从HBase的数据模型上看，数据主要分为两部分：MemStore和HFile。HFile存储于HDFS上，secondary region只要及时获知HFile的变化便可以获取。但MemStore存在于内存，却只有primary region持有。以下便介绍两种secondary region同步数据的方式。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="storefile-refresher">StoreFile Refresher<a class="hash-link" href="#storefile-refresher" title="标题的直接链接">​</a></h4><p>第一种方式是StoreFile Refresher，在HBase-1.0+版本引入。在RegionServer上有一个StorefileRefresherChore任务，会定期地在HDFS上检查primary region的HFile有没有变化，以此来及时的发现primary region通过flush、compact、bulk load等操作产生的新HFile。</p><p>该方案实现上较为简单，也不需要太多多余的存储和网络开销，但缺点也非常明显，在数据写入primary region，到secondary region可以读到数据，有相当长的时间间隔，中间需要等待memstore的flush和StorefileRefresherChore任务的定时刷新。</p><p>如果要开启这个功能，只要将<code>hbase.regionserver.storefile.refresh.period</code>配置设置为非零值即可，表示StorefileRefresherChore任务刷新的时间间隔。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="asynchronous-replication">Asynchronous Replication<a class="hash-link" href="#asynchronous-replication" title="标题的直接链接">​</a></h4><p>HBase有提供集群间replication功能，利用WAL在多个集群之间同步数据。在HBase-1.1+版本中，便利用replication在集群内部同步数据，将实时写入的WAL同步到secondary region。</p><p><img loading="lazy" alt="Asynchronous Replication示意图" src="/assets/images/region_replica_replication-0e540a03227d17865c1070363956a8bb.png" title="Asynchronous Replication 示意图" width="552" height="495" class="img_ev3q"></p><p>如上图中所示，通过实现一个特殊的<code>ReplicationEndpoint</code>便可以将WAL的数据同步给集群中的其他RegionServer。如此primary region MemStore中的数据，也通过replication实时同步到secondary region，从secondary region中也可以读到primary region还没有flush到HFile的数据。所以利用<code>Asnyc WAL replication</code>的同步方式比上面讲到的<code>StoreFile Refresher</code>同步方式具有更低的同步延迟。</p><p>primary region还会将flush、compaction和bulk load事件写到WAL，同样由replication功能同步到secondary region。当secondary region接收到这些事件时，便也回放同样的事件来更新自己的数据。所以对HFile文件列表的更新也比<code>StoreFile Refresher</code>定时刷新的方式更加实时。</p><p>在这种同步模式下，secondary region的MemStore中也是有数据，从WAL同步的Put/Delete操作就pPrimaryrRegion一样写入MemStore，并且secondary region也会使用block cache，所以在这种模式中内存的开销会成倍的增长。不同于primary region的是，secondary region在接收到flush事件时，并不会将MemStore中的数据flush成HFile，只会释放掉MemStore占用的内存。</p><p><code>Asnyc WAL replication</code>功能默认是关闭的。需要设置<code>hbase.region.replica.replication.enabled</code>为<code>true</code>来打开这个功能。当第一次创建一个region replication大于1的表时，将会创建一个名为<code>region_replica_replication</code>的replication peer，这个replication peer将负责集群内所有表region replica的数据同步。一旦开启之后想要再关闭该功能，就不只是改<code>hbase.region.replica.replication.enabled</code>为<code>false</code>了，还需要disable掉<code>region_replica_replication</code>这个replication peer。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="存在的问题">存在的问题<a class="hash-link" href="#存在的问题" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="hfile的过期时间">HFile的过期时间<a class="hash-link" href="#hfile的过期时间" title="标题的直接链接">​</a></h4><p>在以上两种数据同步方式中，都会在多个RegionServer上打开同一个HFile，所以当primary region进行完了major compaction之后，secondary region因为HFile文件变化更新不及时，依旧引用着旧的HFile。目前并没有有效的措施保证HFile文件并不会被过早的删除。只能是将配置项<code>hbase.master.hfilecleaner.ttl</code>设置为一个较大的值，比如一小时，以此来尽量避免请求过程中不会出错。但同时也会增加HDFS的存储开销。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="replication不能同步meta表数据">replication不能同步meta表数据<a class="hash-link" href="#replication不能同步meta表数据" title="标题的直接链接">​</a></h4><p>目前的Asynchronous Replication功能并不能同步meta表的WAL数据（最初该功能是用于集群间同步数据的，毕竟不能把meta数据同步给其他集群）。所以对于meta表的操作，并不能通过replication尽快的同步到secondary region，只能通过类似于<code>StoreFile Refresher</code>的方式，使用定时刷新的任务来同步meta表HFile文件的变化。</p><p><code>hbase.regionserver.meta.storefile.refresh.period</code>配置项用于控制meta表StoreFile的更新时间。该配置项并不同于<code>StoreFile Refresher</code>功能的<code>hbase.regionserver.storefile.refresh.period</code>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="内存消耗">内存消耗<a class="hash-link" href="#内存消耗" title="标题的直接链接">​</a></h4><p>在之前已经提到，Asynchronous Replication同步因为使用MemStore和block cache，会导致内存开销成倍增加。并且secondary region并不会主动进行flush，只会当接收到同步的WAL中的flush事件时，才会进行flush。在一些极端情况下，比如replication阻塞收不到flush事件、primary region确实长时间没有进行flushsecondaryarRegion持有的内存得不到释放，而一个RegionServer上同时有多个primary region和secondary region，内存的过度消耗可能会阻塞primary region正常的写入操作，也会阻塞replication同步的flush事件。</p><p>所以HBase提供了一个配置项<code>hbase.region.replica.storefile.refresh.memstore.multiplier</code>，默认值为4，表示如果secondary region的MemStore比primary region最大的MemStore的4倍还要大时，便允secondaryarRegion自行refresh检查HFile文件是否变化，如果primary region早已flush过，却因为replication阻塞没有同步到，则可以利用该机制进行flush。默认情况下最好不要执行这个操作，可以把该配置项设置大一些来避免。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="secondary-region-failover">secondary region Failover<a class="hash-link" href="#secondary-region-failover" title="标题的直接链接">​</a></h4><p>当一个secondary region刚open或者fail over，此时必然丢失了之前MemStore的数据，因为secondary region毕竟不能像primary region一样通过回放WAL来恢复MemStore。如果此时直接提供读服务，则可能出现数据版本回退的问题，即恢复之后比恢复之前读到的数据更旧。为了避免数据回退，secondary region就必须等待primary region进行一次完整的flush操作或open region事件，在这之前，secondary region都将拒绝接服务。</p><p><code>hbase.region.replica.wait.for.primary.flush</code>配置项是该机制的开关，默认是<code>enable</code>开启。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用">使用<a class="hash-link" href="#使用" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="配置">配置<a class="hash-link" href="#配置" title="标题的直接链接">​</a></h3><p><strong>server端</strong></p><table><thead><tr><th>配置项</th><th>默认值</th><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>hbase.regionserver.storefile.refresh.period</td><td>0</td><td>毫秒</td><td>secondary region刷新storefile的时间间隔，默认0为关闭</td></tr><tr><td>hbase.regionserver.meta.storefile.refresh.period</td><td>0</td><td>毫秒</td><td>secondary region刷新hbase:meta表storefile的时间间隔，默认0为关闭</td></tr><tr><td>hbase.region.replica.replication.enabled</td><td>false</td><td></td><td>是否开启<code>Asnyc WAL replication</code>功能，开启后再想关闭，需要改为false之后再disable掉<code>region_replica_replication</code>的peer</td></tr><tr><td>hbase.master.hfilecleaner.ttl</td><td>300000(5分钟)</td><td>毫秒</td><td>storefile文件的过期删除时间间隔</td></tr><tr><td>hbase.meta.replica.count</td><td>1</td><td>个</td><td>meta表的region replication数量</td></tr><tr><td>hbase.region.replica.storefile.refresh.memstore.multiplier</td><td>4</td><td>倍</td><td>secondary region的MemStore大于同RegionServer上primary region最大的MemStore该倍数时，会触发刷新storefile文件列表的任务</td></tr><tr><td>hbase.region.replica.wait.for.primary.flush</td><td>true</td><td></td><td>secondary region open之后，是否要等待primary region进行一次flush再提供服务</td></tr><tr><td>hbase.master.loadbalancer.class</td><td>org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer</td><td></td><td>默认的实现可以保证region的replicas尽量不会分布在同一个RegionServer上，如果修改该配置，要注意replicas的分布</td></tr></tbody></table><p><strong>client端</strong></p><table><thead><tr><th>配置项</th><th>默认值</th><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>hbase.ipc.client.specificThreadForWriting</td><td>false</td><td></td><td>是否使用特殊线程用于写请求。使用region replicas功能，经常会在IO过程中中断线程，所以必须开启该配置</td></tr><tr><td>hbase.client.primaryCallTimeout.get</td><td>10000</td><td>微秒</td><td>TIMELINE一致性Get时，等待primary region响应的时间，超时之后便请求secondary region</td></tr><tr><td>hbase.client.primaryCallTimeout.scan</td><td>10000</td><td>微秒</td><td>TIMELINE一致性Scan时，等待primary region响应的时间，超时之后便请求secondary region</td></tr><tr><td>hbase.meta.replicas.use</td><td>false</td><td></td><td>是否使用meta表的secondary region</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="建表">建表<a class="hash-link" href="#建表" title="标题的直接链接">​</a></h3><p><code>REGION_REPLICATION</code>参数控制表中region有多少备份，默认值为1，即只有primary region。</p><p>shell方式建表</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">create </span><span class="token string" style="color:#e3116c">'t1'</span><span class="token plain">, </span><span class="token string" style="color:#e3116c">'f1'</span><span class="token plain">, </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">REGION_REPLICATION </span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>shell方式修改表</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">alter </span><span class="token string" style="color:#e3116c">'t1'</span><span class="token plain">, </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">REGION_REPLICATION </span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="client">Client<a class="hash-link" href="#client" title="标题的直接链接">​</a></h3><p>Client访问secondary region必须要用户明确的表示可以接收非强一致性的数据，如果希望请求可以发送给secondary region，必须明确指定为<code>TIMELINE</code>的一致性。</p><div class="language-Java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public enum Consistency {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    STRONG,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TIMELINE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="shell">Shell<a class="hash-link" href="#shell" title="标题的直接链接">​</a></h4><p>允许以<code>TIMELINE</code>的一致性读取数据</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">hbase</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">main</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">:001:</span><span class="token operator file-descriptor important" style="color:#393A34">0</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> get </span><span class="token string" style="color:#e3116c">'t1'</span><span class="token plain">,</span><span class="token string" style="color:#e3116c">'r6'</span><span class="token plain">, </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">CONSISTENCY </span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"TIMELINE"</span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">hbase</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">main</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">:001:</span><span class="token operator file-descriptor important" style="color:#393A34">0</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> get </span><span class="token string" style="color:#e3116c">'t1'</span><span class="token plain">,</span><span class="token string" style="color:#e3116c">'r6'</span><span class="token plain">, </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">CONSISTENCY </span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"TIMELINE"</span><span class="token plain">, , REGION_REPLICA_ID </span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="java">Java<a class="hash-link" href="#java" title="标题的直接链接">​</a></h4><p>Get</p><div class="language-Java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Get get = new Get(row);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">get.setConsistency(Consistency.TIMELINE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Result result = table.get(get);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Scan</p><div class="language-Java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Scan scan = new Scan();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scan.setConsistency(Consistency.TIMELINE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ResultScanner scanner = table.getScanner(scan);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以通过<code>Result.isStale()</code>判断数据是否来自于secondary region</p><div class="language-Java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Result result = table.get(get);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (result.isStale()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="性能测试">性能测试<a class="hash-link" href="#性能测试" title="标题的直接链接">​</a></h2><p><strong>机器配置</strong></p><p>HBase版本：2.2.0
HDFS版本： 3.1.4</p><table><thead><tr><th>service</th><th>job</th><th>实例数</th><th>cpu</th><th>disk</th><th>netowork</th><th>comment</th></tr></thead><tbody><tr><td>HBase</td><td>master</td><td>2</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>HBase</td><td>region server</td><td>5</td><td>24 core</td><td>12*3.7T HDD</td><td>10000bps</td><td>onheap=50g/offheap=50g</td></tr><tr><td>HDFS</td><td>namenode</td><td>2</td><td>-</td><td>-</td><td>-</td><td>onheap=10g</td></tr><tr><td>HDFS</td><td>datanode</td><td>5</td><td>24 core</td><td>12*3.7T HDD</td><td>10000bps</td><td>onheap=2g</td></tr></tbody></table><p><strong>不限制QPS</strong></p><table><thead><tr><th></th><th>strong</th><th>timeline-10ms</th><th>reta</th></tr></thead><tbody><tr><td>qps_sec</td><td>12608.23</td><td>11171.18</td><td>-11.4%</td></tr><tr><td>max_latency_us</td><td>195174.38</td><td>202603.69</td><td>3.81%</td></tr><tr><td>min_latency_us</td><td>149.38</td><td>148.75</td><td>-0.42%</td></tr><tr><td>avg_latency_us</td><td>3760.69</td><td>4276.76</td><td>13.72%</td></tr><tr><td>p90_latency_us</td><td>11811.92</td><td>14258.31</td><td>20.71%</td></tr><tr><td>p99_latency_us</td><td>32512.23</td><td>31148.14</td><td>-4.2%</td></tr><tr><td>p999_latency_us</td><td>64646.38</td><td>58621.93</td><td>-9.32%</td></tr><tr><td>p9999_latency_us</td><td>136835.92</td><td>115951.63</td><td>-15.26%</td></tr></tbody></table><p><strong>限制7000QPS</strong></p><table><thead><tr><th></th><th>strong</th><th>timeline-10ms</th><th>reta</th></tr></thead><tbody><tr><td>qps_sec</td><td>6999.58</td><td>6999.56</td><td>-0.0%</td></tr><tr><td>max_latency_us</td><td>126860.75</td><td>130148.86</td><td>2.59%</td></tr><tr><td>min_latency_us</td><td>147.25</td><td>150.68</td><td>2.33%</td></tr><tr><td>avg_latency_us</td><td>3223.38</td><td>3495.51</td><td>8.44%</td></tr><tr><td>p90_latency_us</td><td>10612.49</td><td>11379.48</td><td>7.23%</td></tr><tr><td>p99_latency_us</td><td>23793.54</td><td>24469.25</td><td>2.84%</td></tr><tr><td>p999_latency_us</td><td>48791.00</td><td>39795.06</td><td>-18.44%</td></tr><tr><td>p9999_latency_us</td><td>93389.08</td><td>78618.61</td><td>-15.82%</td></tr></tbody></table><p>对单Client实例做压力测试，<code>hbase.client.primaryCallTimeout.get</code>参数设置为10000，即等待primary region响应的时间超时10ms之后便请求secondary region。</p><p>第一组极限QPS的压测中，可以看出开启TIMELINE Read之后，QPS有一定损失，平均延迟有一定升高，P999和P9999一定程度优化。优化效果有限。</p><p>因为read replicas会增加线程资源的使用，而日常使用也不会把Client侧压到极限，所以又做了一组限制QPS的压测，可以看到各项延迟指标均有所好转。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a class="hash-link" href="#总结" title="标题的直接链接">​</a></h2><p><code>Region Replica</code>功能可以提高HBase的读可用性，但也要根据具体的用例考虑是否适用。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="优点">优点<a class="hash-link" href="#优点" title="标题的直接链接">​</a></h3><ul><li>当应用依赖是只读的表，或者应用并不要求强一致性（要求最终一致性，可以接受短时间内数据不一致）时，可以使用该功能来提高读可用性。在RegionServer或Region出现单点故障恢复期间或长时间Full GC期间尽量保证业务读请求正常，减少MTTR过长对业务产生的影响，同时也可以减少大量重试请求进一步地增加故障节点的压力。</li><li>对于部分不要求强一致性且对延迟毛刺有一定要求的应用，当在Client侧QPS较低或CPU、带宽等资源富余时，可以使用该功能降低读请求P99/P999和P9999延迟。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="缺点">缺点<a class="hash-link" href="#缺点" title="标题的直接链接">​</a></h3><ul><li>多倍的MemStore导致更多的内存消耗</li><li>增加block cache的需求和使用</li><li>为了传输WAL导致更多的网络带宽消耗</li><li>大量的集群内部RPC请求</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a class="hash-link" href="#参考" title="标题的直接链接">​</a></h2><ul><li><a href="http://hbase.apache.org/book.html#arch.timelineconsistent.reads" target="_blank" rel="noopener noreferrer">Timeline-consistent High Available Reads</a></li><li><a href="https://issues.apache.org/jira/browse/HBASE-10070" target="_blank" rel="noopener noreferrer">HBASE-10070</a></li><li><a href="https://issues.apache.org/jira/secure/attachment/12616659/HighAvailabilityDesignforreadsApachedoc.pdf" target="_blank" rel="noopener noreferrer">HighAvailabilityDesignforreadsApachedoc.pdf</a></li></ul>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="HBase" term="HBase"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[「记」Jdk8 CompletableFuture在高并发环境下的性能问题]]></title>
        <id>CompletableFuture-in-high-concurrent</id>
        <link href="https://ddupg.github.io/blog/CompletableFuture-in-high-concurrent"/>
        <updated>2019-10-11T19:30:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<p>最近的工作内容就是写一个 <code>DualHBaseClient</code>，在查询数据时间过长时，能够将同样的请求发给 replication 的集群，缩小 client 端的 p99、p999 延迟，减小毛刺。
实际开发最初的一版代码都没有花费1pd，性能测试倒测了好几天都不及预期，甚至优化之后各方面性能更差劲。</p><p>本文就是记录下导致此次性能问题的主要原因：CompletableFuture.</p><p>使用 Java 异步编程的时候，<code>CompletableFuture</code> 用起来还是相当舒服的，在HBase的异步API里，也大量的使用了<code>CompletableFuture</code>，如果 <code>CompletableFuture</code> 有性能问题，那可就悲催了。</p><p>看下以下这段测试<code>CompletableFuture</code>的代码</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import com.google.common.collect.Lists;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.List;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.CompletableFuture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.ExecutionException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FutureTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ExecutionException, InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new FutureTest().run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void run() throws ExecutionException, InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;CompletableFuture&gt; futures = Lists.newArrayList();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 1000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            CompletableFuture future = new CompletableFuture();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            CompletableFuture f = CompletableFuture.runAsync(this::read);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            f.whenComplete((r, e) -&gt; future.complete(r));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            futures.add(future);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (CompletableFuture future : futures) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            future.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void read() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以上这段代码实际只是让 <code>CompletableFuture</code> 空转，除了 sleep 没再做其他的，循环1000让运行时间尽量长一些，足够让我们跑一个火焰图出来。</p><p><img loading="lazy" alt="火焰图" src="/assets/images/CompletableFuture-in-jdk8-traces-5268b75d0499fa3aef10b4efa6ab80c8.svg" width="1200" height="742" class="img_ev3q"></p><p>火焰图里注意到有个最大的平顶 <code>java.lang.Runtime.availableProcessors</code>，该方法耗时极大，甚至超过了 Thread.sleep，这可不正常吧。</p><p>随后我们测下 <code>java.lang.Runtime.availableProcessors()</code> 方法是不是真的慢。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import com.google.common.base.Stopwatch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.junit.Assert;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.junit.Test;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.TimeUnit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AvailableProcessorsTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stopwatch sw = Stopwatch.createStarted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 1000000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Runtime.getRuntime().availableProcessors();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assert.assertTrue(sw.elapsed(TimeUnit.SECONDS) &gt; 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在我的机器上循环1000000次，耗时超过了10s，不算快。</p><p>再来看看 <code>CompletableFuture</code> 是怎么使用 <code>Runtime.availableProcessors()</code> 的</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private Object waitingGet(boolean interruptible) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while ((r = result) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (spins &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            spins = (Runtime.getRuntime().availableProcessors() &gt; 1) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                1 &lt;&lt; 8 : 0; // Use brief spin-wait on multiprocessors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (spins &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ThreadLocalRandom.nextSecondarySeed() &gt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                --spins;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>while 死循环要直到出现异常或获取到最终结果才会结束，而循环中又会大量调用 <code>Runtime.availableProcessors()</code>，这就是<code>CompletableFuture</code>存在的性能问题。</p><p>而实际上Openjdk已有对该问题的讨论，<a href="https://bugs.openjdk.java.net/browse/JDK-8227018" target="_blank" rel="noopener noreferrer">JDK-8227018</a>，该优化也很简单，在这里其实只是需要知道运行环境是不是多处理器环境而已，缓存起来就好，完全没必要每次循环都去获取。在jdk8u232版本就fix掉了。</p><p>而且我还看了 jdk11、jdk13 的实现，都不再使用<code>Runtime.availableProcessors()</code>了，所以算是低版本 jdk8 用户独有的烦恼。</p><blockquote><p>一个小插曲</p><p>jdk8u232版本是2019.10.15才正式release的，而我发现这个问题是在10.13。
也幸运也不幸，幸运的是起码问题fix掉了，不幸的是 DualHBaseClient 不能采用 CompletableFuture 实现了，总不好要求用户升级jdk吧</p></blockquote><p>知道低版本的 jdk8 有问题之后，<code>DualHBaseClient</code> 还是要写的，只能寻求其他的异步框架来实现，好在 guava 的 <code>ListenableFuture</code> 实现很像<code>CompletableFuture</code>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a class="hash-link" href="#总结" title="标题的直接链接">​</a></h2><p>如果是jdk8低版本用户（刚发布几天不会有公司升级吧）频繁的大量使用 CompletableFuture，是存在性能问题，升级 jdk 是最简单的办法，使用 guava 的 Future 库实现也可以，但可能要大量修改代码了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="附录">附录<a class="hash-link" href="#附录" title="标题的直接链接">​</a></h2><ul><li><a href="https://blog.wangqi.love/articles/Java/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%8E%92%E6%9F%A5Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener noreferrer">火焰图排查Java性能问题</a></li><li><a href="https://bugs.openjdk.java.net/browse/JDK-8227018" target="_blank" rel="noopener noreferrer">JDK-8227018</a></li></ul>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Jdk" term="Jdk"/>
        <category label="Java" term="Java"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[「记」子类复写父类方法与类初始化顺序引发的bug]]></title>
        <id>class-init-order-in-inheritance</id>
        <link href="https://ddupg.github.io/blog/class-init-order-in-inheritance"/>
        <updated>2019-09-30T10:00:00.000Z</updated>
        <summary type="html"><![CDATA[请输入描述]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bug现象">bug现象<a class="hash-link" href="#bug现象" title="标题的直接链接">​</a></h2><p>bug出现的条件：</p><ul><li>继承关系</li><li>子类属性有默认的初始化</li><li>子类复写了父类的钩子方法</li><li>钩子方法在父类构造方法中调用</li></ul><p>可以看下以下的示例代码</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Father {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Father() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void init() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Child extends Father {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int a = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Child() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void init() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import org.junit.Test;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import static org.junit.Assert.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ChildTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void testConstructor() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Child child = new Child();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assertEquals(0, child.a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类加载过程">类加载过程<a class="hash-link" href="#类加载过程" title="标题的直接链接">​</a></h2><p>顺便复习一下类加载过程，类加载过程分为加载、链接、初始化三大步骤</p><p>加载：查找并加载类的二进制字节流数据，并且据此创建类，即代表这个类的Class对象。</p><p>链接：将创建成的类合并至Java虚拟机中，使之能够执行的过程。还分验证、准备、解析三个阶段。</p><ul><li>验证：确保被加载类的正确性</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li><li>解析：把类中的符号引用转换为直接引用</li></ul><p>初始化：标记为常量值的字段赋值，以及执行方法。初始化的时机：</p><ol><li>虚拟机启动时，初始化用户指定的主类</li><li>当遇到以新建目标类实例的new指令时，初始化new指定的目标类</li><li>当遇到调用静态方法的指令字段是，初始化该静态方法所在的类</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类</li><li>子类的初始化会触发父类的初始化</li><li>如果一个接口定义了default方法，那么直接或间接实现该接口的类初始化，会触</li><li>该接口的初始化</li><li>使用反射API对某个类进行反射调用时，初始化这个类</li><li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类初始化顺序">类初始化顺序<a class="hash-link" href="#类初始化顺序" title="标题的直接链接">​</a></h2><ol><li>按定义顺序初始化父类的static成员，在准备阶段完成</li><li>按定义顺序初始化子类的static成员，在准备阶段完成</li><li>按定义顺序执行父类的普通成员初始化</li><li>执行父类的构造函数</li><li>按定义顺序执行子类的指定初始化</li><li>执行子类的构造函数</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="回头解bug">回头解bug<a class="hash-link" href="#回头解bug" title="标题的直接链接">​</a></h2><p>现在再回头看下bug代码就知道是什么原因：父类执行构造方法时调用了会修改子类成员<code>a</code>的钩子方法，然后子类才初始化了自己的成员，覆盖了钩子方法里对<code>a</code>的修改。</p><p>解决方法也简单，对<code>a</code>不加默认值就好了。</p>]]></content>
        <author>
            <name>Ddupg</name>
            <uri>https://ddupg.github.io</uri>
        </author>
        <category label="Java" term="Java"/>
        <category label="Bug" term="Bug"/>
    </entry>
</feed>